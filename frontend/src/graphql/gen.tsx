/* eslint-disable react-refresh/only-export-components */
import gql from 'graphql-tag'
import * as React from 'react'
import * as Urql from 'urql'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never }
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never }
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string }
  String: { input: string; output: string }
  Boolean: { input: boolean; output: boolean }
  Int: { input: number; output: number }
  Float: { input: number; output: number }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: any; output: any }
  Duration: { input: any; output: any }
  /** A valid JSON string. */
  JSON: { input: any; output: any }
  Time: { input: any; output: any }
  UUID: { input: any; output: any }
  Upload: { input: any; output: any }
}

export type ApiKey = Node & {
  __typename?: 'ApiKey'
  apiKey: Scalars['String']['output']
  createdAt: Scalars['Time']['output']
  expiresOn: Scalars['Time']['output']
  id: Scalars['ID']['output']
  owner: User
  updatedAt: Scalars['Time']['output']
}

/** Return response for createBulkApiKey mutation */
export type ApiKeyBulkCreatePayload = {
  __typename?: 'ApiKeyBulkCreatePayload'
  /** Created apiKeys */
  apiKeys?: Maybe<Array<ApiKey>>
}

/** A connection to a list of items. */
export type ApiKeyConnection = {
  __typename?: 'ApiKeyConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ApiKeyEdge>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output']
}

/** Return response for createApiKey mutation */
export type ApiKeyCreatePayload = {
  __typename?: 'ApiKeyCreatePayload'
  /** Created apiKey */
  apiKey: ApiKey
}

/** Return response for deleteApiKey mutation */
export type ApiKeyDeletePayload = {
  __typename?: 'ApiKeyDeletePayload'
  /** Deleted apiKey ID */
  deletedID: Scalars['ID']['output']
}

/** An edge in a connection. */
export type ApiKeyEdge = {
  __typename?: 'ApiKeyEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output']
  /** The item at the end of the edge. */
  node?: Maybe<ApiKey>
}

/** Ordering options for ApiKey connections */
export type ApiKeyOrder = {
  /** The ordering direction. */
  direction?: OrderDirection
  /** The field by which to order ApiKeys. */
  field: ApiKeyOrderField
}

/** Properties by which ApiKey connections can be ordered. */
export type ApiKeyOrderField = 'CREATED_AT' | 'ID' | 'UPDATED_AT'

/** Return response for updateApiKey mutation */
export type ApiKeyUpdatePayload = {
  __typename?: 'ApiKeyUpdatePayload'
  /** Updated apiKey */
  apiKey: ApiKey
}

/**
 * ApiKeyWhereInput is used for filtering ApiKey objects.
 * Input was generated by ent.
 */
export type ApiKeyWhereInput = {
  and?: InputMaybe<Array<ApiKeyWhereInput>>
  /** api_key field predicates */
  apiKey?: InputMaybe<Scalars['String']['input']>
  apiKeyContains?: InputMaybe<Scalars['String']['input']>
  apiKeyContainsFold?: InputMaybe<Scalars['String']['input']>
  apiKeyEqualFold?: InputMaybe<Scalars['String']['input']>
  apiKeyGT?: InputMaybe<Scalars['String']['input']>
  apiKeyGTE?: InputMaybe<Scalars['String']['input']>
  apiKeyHasPrefix?: InputMaybe<Scalars['String']['input']>
  apiKeyHasSuffix?: InputMaybe<Scalars['String']['input']>
  apiKeyIn?: InputMaybe<Array<Scalars['String']['input']>>
  apiKeyLT?: InputMaybe<Scalars['String']['input']>
  apiKeyLTE?: InputMaybe<Scalars['String']['input']>
  apiKeyNEQ?: InputMaybe<Scalars['String']['input']>
  apiKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>
  createdAtGT?: InputMaybe<Scalars['Time']['input']>
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  createdAtLT?: InputMaybe<Scalars['Time']['input']>
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  /** expires_on field predicates */
  expiresOn?: InputMaybe<Scalars['Time']['input']>
  expiresOnGT?: InputMaybe<Scalars['Time']['input']>
  expiresOnGTE?: InputMaybe<Scalars['Time']['input']>
  expiresOnIn?: InputMaybe<Array<Scalars['Time']['input']>>
  expiresOnLT?: InputMaybe<Scalars['Time']['input']>
  expiresOnLTE?: InputMaybe<Scalars['Time']['input']>
  expiresOnNEQ?: InputMaybe<Scalars['Time']['input']>
  expiresOnNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']['input']>
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>
  idGT?: InputMaybe<Scalars['ID']['input']>
  idGTE?: InputMaybe<Scalars['ID']['input']>
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>
  idLT?: InputMaybe<Scalars['ID']['input']>
  idLTE?: InputMaybe<Scalars['ID']['input']>
  idNEQ?: InputMaybe<Scalars['ID']['input']>
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>
  not?: InputMaybe<ApiKeyWhereInput>
  or?: InputMaybe<Array<ApiKeyWhereInput>>
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
}

export type Comment = Node & {
  __typename?: 'Comment'
  content: Scalars['String']['output']
  createdAt: Scalars['Time']['output']
  deletedAt?: Maybe<Scalars['Time']['output']>
  deletedBy?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  owner: User
  post?: Maybe<Post>
  updatedAt: Scalars['Time']['output']
}

/** Return response for createBulkComment mutation */
export type CommentBulkCreatePayload = {
  __typename?: 'CommentBulkCreatePayload'
  /** Created comments */
  comments?: Maybe<Array<Comment>>
}

/** A connection to a list of items. */
export type CommentConnection = {
  __typename?: 'CommentConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output']
}

/** Return response for createComment mutation */
export type CommentCreatePayload = {
  __typename?: 'CommentCreatePayload'
  /** Created comment */
  comment: Comment
}

/** Return response for deleteComment mutation */
export type CommentDeletePayload = {
  __typename?: 'CommentDeletePayload'
  /** Deleted comment ID */
  deletedID: Scalars['ID']['output']
}

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: 'CommentEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Comment>
}

/** Ordering options for Comment connections */
export type CommentOrder = {
  /** The ordering direction. */
  direction?: OrderDirection
  /** The field by which to order Comments. */
  field: CommentOrderField
}

/** Properties by which Comment connections can be ordered. */
export type CommentOrderField = 'CREATED_AT' | 'ID' | 'UPDATED_AT'

/** Return response for updateComment mutation */
export type CommentUpdatePayload = {
  __typename?: 'CommentUpdatePayload'
  /** Updated comment */
  comment: Comment
}

/**
 * CommentWhereInput is used for filtering Comment objects.
 * Input was generated by ent.
 */
export type CommentWhereInput = {
  and?: InputMaybe<Array<CommentWhereInput>>
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>
  contentContains?: InputMaybe<Scalars['String']['input']>
  contentContainsFold?: InputMaybe<Scalars['String']['input']>
  contentEqualFold?: InputMaybe<Scalars['String']['input']>
  contentGT?: InputMaybe<Scalars['String']['input']>
  contentGTE?: InputMaybe<Scalars['String']['input']>
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>
  contentLT?: InputMaybe<Scalars['String']['input']>
  contentLTE?: InputMaybe<Scalars['String']['input']>
  contentNEQ?: InputMaybe<Scalars['String']['input']>
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>
  createdAtGT?: InputMaybe<Scalars['Time']['input']>
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  createdAtLT?: InputMaybe<Scalars['Time']['input']>
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** deleted_by field predicates */
  deletedBy?: InputMaybe<Scalars['String']['input']>
  deletedByContains?: InputMaybe<Scalars['String']['input']>
  deletedByContainsFold?: InputMaybe<Scalars['String']['input']>
  deletedByEqualFold?: InputMaybe<Scalars['String']['input']>
  deletedByGT?: InputMaybe<Scalars['String']['input']>
  deletedByGTE?: InputMaybe<Scalars['String']['input']>
  deletedByHasPrefix?: InputMaybe<Scalars['String']['input']>
  deletedByHasSuffix?: InputMaybe<Scalars['String']['input']>
  deletedByIn?: InputMaybe<Array<Scalars['String']['input']>>
  deletedByIsNil?: InputMaybe<Scalars['Boolean']['input']>
  deletedByLT?: InputMaybe<Scalars['String']['input']>
  deletedByLTE?: InputMaybe<Scalars['String']['input']>
  deletedByNEQ?: InputMaybe<Scalars['String']['input']>
  deletedByNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  deletedByNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']['input']>
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>
  hasPostWith?: InputMaybe<Array<PostWhereInput>>
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>
  idGT?: InputMaybe<Scalars['ID']['input']>
  idGTE?: InputMaybe<Scalars['ID']['input']>
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>
  idLT?: InputMaybe<Scalars['ID']['input']>
  idLTE?: InputMaybe<Scalars['ID']['input']>
  idNEQ?: InputMaybe<Scalars['ID']['input']>
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>
  not?: InputMaybe<CommentWhereInput>
  or?: InputMaybe<Array<CommentWhereInput>>
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
}

/**
 * CreateApiKeyInput is used for create ApiKey object.
 * Input was generated by ent.
 */
export type CreateApiKeyInput = {
  apiKey: Scalars['String']['input']
  expiresOn: Scalars['Time']['input']
  ownerID: Scalars['ID']['input']
}

/**
 * CreateCommentInput is used for create Comment object.
 * Input was generated by ent.
 */
export type CreateCommentInput = {
  content: Scalars['String']['input']
  ownerID: Scalars['ID']['input']
  postID?: InputMaybe<Scalars['ID']['input']>
}

/**
 * CreatePostCategoryInput is used for create PostCategory object.
 * Input was generated by ent.
 */
export type CreatePostCategoryInput = {
  category: PostCategoryCategory
  postID?: InputMaybe<Scalars['ID']['input']>
}

/**
 * CreatePostInput is used for create Post object.
 * Input was generated by ent.
 */
export type CreatePostInput = {
  categoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  commentIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  content?: InputMaybe<Scalars['String']['input']>
  isModerated?: InputMaybe<Scalars['Boolean']['input']>
  likedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  link: Scalars['String']['input']
  moderationComment?: InputMaybe<Scalars['String']['input']>
  ownerID: Scalars['ID']['input']
  pinned?: InputMaybe<Scalars['Boolean']['input']>
  savedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  title: Scalars['String']['input']
}

export type CreatePostWithCategoriesInput = {
  base: CreatePostInput
  categories?: InputMaybe<Array<PostCategoryCategory>>
}

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  /** the alias of the user is shown alongside the display name */
  alias?: InputMaybe<Scalars['String']['input']>
  apiKeyID?: InputMaybe<Scalars['ID']['input']>
  authProvider?: InputMaybe<UserAuthProvider>
  awards?: InputMaybe<Array<Scalars['String']['input']>>
  commentIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  displayName: Scalars['String']['input']
  /** cursor for last post seen */
  lastPostSeenCursor?: InputMaybe<Scalars['String']['input']>
  /** the time the user was last seen */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>
  likedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  profileImage?: InputMaybe<Scalars['String']['input']>
  publishedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  /** the role of the user */
  role?: InputMaybe<UserRole>
  savedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
}

export type Mutation = {
  __typename?: 'Mutation'
  _m?: Maybe<Scalars['Boolean']['output']>
  /** Create a new apiKey */
  createApiKey: ApiKeyCreatePayload
  /** Create multiple new apiKeys */
  createBulkApiKey: ApiKeyBulkCreatePayload
  /** Create multiple new apiKeys via file upload */
  createBulkCSVApiKey: ApiKeyBulkCreatePayload
  /** Create multiple new comments via file upload */
  createBulkCSVComment: CommentBulkCreatePayload
  /** Create multiple new posts via file upload */
  createBulkCSVPost: PostBulkCreatePayload
  /** Create multiple new postCategorys via file upload */
  createBulkCSVPostCategory: PostCategoryBulkCreatePayload
  /** Create multiple new users via file upload */
  createBulkCSVUser: UserBulkCreatePayload
  /** Create multiple new comments */
  createBulkComment: CommentBulkCreatePayload
  /** Create multiple new posts */
  createBulkPost: PostBulkCreatePayload
  /** Create multiple new postCategorys */
  createBulkPostCategory: PostCategoryBulkCreatePayload
  /** Create multiple new users */
  createBulkUser: UserBulkCreatePayload
  /** Create a new comment */
  createComment: CommentCreatePayload
  /** Create a new post */
  createPost: PostCreatePayload
  /** Create a new postCategory */
  createPostCategory: PostCategoryCreatePayload
  createPostWithCategories: PostCreatePayload
  /** Create a new user */
  createUser: UserCreatePayload
  /** Delete an existing apiKey */
  deleteApiKey: ApiKeyDeletePayload
  /** Delete an existing comment */
  deleteComment: CommentDeletePayload
  /** Delete an existing post */
  deletePost: PostDeletePayload
  /** Delete an existing postCategory */
  deletePostCategory: PostCategoryDeletePayload
  /** Delete an existing user */
  deleteUser: UserDeletePayload
  /** Update an existing apiKey */
  updateApiKey: ApiKeyUpdatePayload
  /** Update an existing comment */
  updateComment: CommentUpdatePayload
  /** Update an existing post */
  updatePost: PostUpdatePayload
  /** Update an existing postCategory */
  updatePostCategory: PostCategoryUpdatePayload
  /** Update an existing user */
  updateUser: UserUpdatePayload
}

export type MutationCreateApiKeyArgs = {
  input: CreateApiKeyInput
}

export type MutationCreateBulkApiKeyArgs = {
  input?: InputMaybe<Array<CreateApiKeyInput>>
}

export type MutationCreateBulkCsvApiKeyArgs = {
  input: Scalars['Upload']['input']
}

export type MutationCreateBulkCsvCommentArgs = {
  input: Scalars['Upload']['input']
}

export type MutationCreateBulkCsvPostArgs = {
  input: Scalars['Upload']['input']
}

export type MutationCreateBulkCsvPostCategoryArgs = {
  input: Scalars['Upload']['input']
}

export type MutationCreateBulkCsvUserArgs = {
  input: Scalars['Upload']['input']
}

export type MutationCreateBulkCommentArgs = {
  input?: InputMaybe<Array<CreateCommentInput>>
}

export type MutationCreateBulkPostArgs = {
  input?: InputMaybe<Array<CreatePostInput>>
}

export type MutationCreateBulkPostCategoryArgs = {
  input?: InputMaybe<Array<CreatePostCategoryInput>>
}

export type MutationCreateBulkUserArgs = {
  input?: InputMaybe<Array<CreateUserInput>>
}

export type MutationCreateCommentArgs = {
  input: CreateCommentInput
}

export type MutationCreatePostArgs = {
  input: CreatePostInput
}

export type MutationCreatePostCategoryArgs = {
  input: CreatePostCategoryInput
}

export type MutationCreatePostWithCategoriesArgs = {
  input: CreatePostWithCategoriesInput
}

export type MutationCreateUserArgs = {
  input: CreateUserInput
}

export type MutationDeleteApiKeyArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeleteCommentArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeletePostArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeletePostCategoryArgs = {
  id: Scalars['ID']['input']
}

export type MutationDeleteUserArgs = {
  id: Scalars['ID']['input']
}

export type MutationUpdateApiKeyArgs = {
  id: Scalars['ID']['input']
  input: UpdateApiKeyInput
}

export type MutationUpdateCommentArgs = {
  id: Scalars['ID']['input']
  input: UpdateCommentInput
}

export type MutationUpdatePostArgs = {
  id: Scalars['ID']['input']
  input: UpdatePostInput
}

export type MutationUpdatePostCategoryArgs = {
  id: Scalars['ID']['input']
  input: UpdatePostCategoryInput
}

export type MutationUpdateUserArgs = {
  id: Scalars['ID']['input']
  input: UpdateUserInput
}

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output']
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export type OrderDirection =
  /** Specifies an ascending order for a given `orderBy` argument. */
  | 'ASC'
  /** Specifies a descending order for a given `orderBy` argument. */
  | 'DESC'

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>
}

export type Post = Node & {
  __typename?: 'Post'
  categories?: Maybe<Array<PostCategory>>
  comments: CommentConnection
  content?: Maybe<Scalars['String']['output']>
  createdAt: Scalars['Time']['output']
  deletedAt?: Maybe<Scalars['Time']['output']>
  deletedBy?: Maybe<Scalars['String']['output']>
  entityVector?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  isModerated: Scalars['Boolean']['output']
  likedBy: UserConnection
  link: Scalars['String']['output']
  moderationComment?: Maybe<Scalars['String']['output']>
  nodeId: Scalars['String']['output']
  owner: User
  pinned: Scalars['Boolean']['output']
  savedBy?: Maybe<Array<User>>
  title: Scalars['String']['output']
  toHTML: Scalars['String']['output']
  updatedAt: Scalars['Time']['output']
}

export type PostCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  orderBy?: InputMaybe<CommentOrder>
  where?: InputMaybe<CommentWhereInput>
}

export type PostLikedByArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  orderBy?: InputMaybe<UserOrder>
  where?: InputMaybe<UserWhereInput>
}

/** Return response for createBulkPost mutation */
export type PostBulkCreatePayload = {
  __typename?: 'PostBulkCreatePayload'
  /** Created posts */
  posts?: Maybe<Array<Post>>
}

export type PostCategory = Node & {
  __typename?: 'PostCategory'
  category: PostCategoryCategory
  createdAt: Scalars['Time']['output']
  id: Scalars['ID']['output']
  post?: Maybe<Post>
  updatedAt: Scalars['Time']['output']
}

/** Return response for createBulkPostCategory mutation */
export type PostCategoryBulkCreatePayload = {
  __typename?: 'PostCategoryBulkCreatePayload'
  /** Created postCategorys */
  postCategories?: Maybe<Array<PostCategory>>
}

/** PostCategoryCategory is enum for the field category */
export type PostCategoryCategory =
  | 'ALERTA_GLONETILLO'
  | 'DIAMANTE'
  | 'ENSORDECEDOR'
  | 'GRR'
  | 'MEH'
  | 'MEME_ARTESANAL'
  | 'NO_SE_YO'
  | 'ORO'
  | 'RAGUUUL'
  | 'RANA'
  | 'SIN_SONIDO'

/** A connection to a list of items. */
export type PostCategoryConnection = {
  __typename?: 'PostCategoryConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostCategoryEdge>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output']
}

/** Return response for createPostCategory mutation */
export type PostCategoryCreatePayload = {
  __typename?: 'PostCategoryCreatePayload'
  /** Created postCategory */
  postCategory: PostCategory
}

/** Return response for deletePostCategory mutation */
export type PostCategoryDeletePayload = {
  __typename?: 'PostCategoryDeletePayload'
  /** Deleted postCategory ID */
  deletedID: Scalars['ID']['output']
}

/** An edge in a connection. */
export type PostCategoryEdge = {
  __typename?: 'PostCategoryEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output']
  /** The item at the end of the edge. */
  node?: Maybe<PostCategory>
}

/** Ordering options for PostCategory connections */
export type PostCategoryOrder = {
  /** The ordering direction. */
  direction?: OrderDirection
  /** The field by which to order PostCategories. */
  field: PostCategoryOrderField
}

/** Properties by which PostCategory connections can be ordered. */
export type PostCategoryOrderField = 'CREATED_AT' | 'ID' | 'UPDATED_AT'

/** Return response for updatePostCategory mutation */
export type PostCategoryUpdatePayload = {
  __typename?: 'PostCategoryUpdatePayload'
  /** Updated postCategory */
  postCategory: PostCategory
}

/**
 * PostCategoryWhereInput is used for filtering PostCategory objects.
 * Input was generated by ent.
 */
export type PostCategoryWhereInput = {
  and?: InputMaybe<Array<PostCategoryWhereInput>>
  /** category field predicates */
  category?: InputMaybe<PostCategoryCategory>
  categoryIn?: InputMaybe<Array<PostCategoryCategory>>
  categoryNEQ?: InputMaybe<PostCategoryCategory>
  categoryNotIn?: InputMaybe<Array<PostCategoryCategory>>
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>
  createdAtGT?: InputMaybe<Scalars['Time']['input']>
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  createdAtLT?: InputMaybe<Scalars['Time']['input']>
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>
  hasPostWith?: InputMaybe<Array<PostWhereInput>>
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>
  idGT?: InputMaybe<Scalars['ID']['input']>
  idGTE?: InputMaybe<Scalars['ID']['input']>
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>
  idLT?: InputMaybe<Scalars['ID']['input']>
  idLTE?: InputMaybe<Scalars['ID']['input']>
  idNEQ?: InputMaybe<Scalars['ID']['input']>
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>
  not?: InputMaybe<PostCategoryWhereInput>
  or?: InputMaybe<Array<PostCategoryWhereInput>>
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
}

/** A connection to a list of items. */
export type PostConnection = {
  __typename?: 'PostConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostEdge>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output']
}

/** Return response for createPost mutation */
export type PostCreatePayload = {
  __typename?: 'PostCreatePayload'
  /** Created post */
  post: Post
}

/** Return response for deletePost mutation */
export type PostDeletePayload = {
  __typename?: 'PostDeletePayload'
  /** Deleted post ID */
  deletedID: Scalars['ID']['output']
}

/** An edge in a connection. */
export type PostEdge = {
  __typename?: 'PostEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Post>
}

/** Ordering options for Post connections */
export type PostOrder = {
  /** The ordering direction. */
  direction?: OrderDirection
  /** The field by which to order Posts. */
  field: PostOrderField
}

/** Properties by which Post connections can be ordered. */
export type PostOrderField = 'COMMENTS_COUNT' | 'CREATED_AT' | 'ID' | 'LIKED_BY_COUNT' | 'UPDATED_AT'

/** Return response for updatePost mutation */
export type PostUpdatePayload = {
  __typename?: 'PostUpdatePayload'
  /** Updated post */
  post: Post
}

/**
 * PostWhereInput is used for filtering Post objects.
 * Input was generated by ent.
 */
export type PostWhereInput = {
  and?: InputMaybe<Array<PostWhereInput>>
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>
  contentContains?: InputMaybe<Scalars['String']['input']>
  contentContainsFold?: InputMaybe<Scalars['String']['input']>
  contentEqualFold?: InputMaybe<Scalars['String']['input']>
  contentGT?: InputMaybe<Scalars['String']['input']>
  contentGTE?: InputMaybe<Scalars['String']['input']>
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>
  contentIsNil?: InputMaybe<Scalars['Boolean']['input']>
  contentLT?: InputMaybe<Scalars['String']['input']>
  contentLTE?: InputMaybe<Scalars['String']['input']>
  contentNEQ?: InputMaybe<Scalars['String']['input']>
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  contentNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>
  createdAtGT?: InputMaybe<Scalars['Time']['input']>
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  createdAtLT?: InputMaybe<Scalars['Time']['input']>
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** deleted_by field predicates */
  deletedBy?: InputMaybe<Scalars['String']['input']>
  deletedByContains?: InputMaybe<Scalars['String']['input']>
  deletedByContainsFold?: InputMaybe<Scalars['String']['input']>
  deletedByEqualFold?: InputMaybe<Scalars['String']['input']>
  deletedByGT?: InputMaybe<Scalars['String']['input']>
  deletedByGTE?: InputMaybe<Scalars['String']['input']>
  deletedByHasPrefix?: InputMaybe<Scalars['String']['input']>
  deletedByHasSuffix?: InputMaybe<Scalars['String']['input']>
  deletedByIn?: InputMaybe<Array<Scalars['String']['input']>>
  deletedByIsNil?: InputMaybe<Scalars['Boolean']['input']>
  deletedByLT?: InputMaybe<Scalars['String']['input']>
  deletedByLTE?: InputMaybe<Scalars['String']['input']>
  deletedByNEQ?: InputMaybe<Scalars['String']['input']>
  deletedByNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  deletedByNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** entity_vector field predicates */
  entityVector?: InputMaybe<Scalars['String']['input']>
  entityVectorContains?: InputMaybe<Scalars['String']['input']>
  entityVectorContainsFold?: InputMaybe<Scalars['String']['input']>
  entityVectorEqualFold?: InputMaybe<Scalars['String']['input']>
  entityVectorGT?: InputMaybe<Scalars['String']['input']>
  entityVectorGTE?: InputMaybe<Scalars['String']['input']>
  entityVectorHasPrefix?: InputMaybe<Scalars['String']['input']>
  entityVectorHasSuffix?: InputMaybe<Scalars['String']['input']>
  entityVectorIn?: InputMaybe<Array<Scalars['String']['input']>>
  entityVectorIsNil?: InputMaybe<Scalars['Boolean']['input']>
  entityVectorLT?: InputMaybe<Scalars['String']['input']>
  entityVectorLTE?: InputMaybe<Scalars['String']['input']>
  entityVectorNEQ?: InputMaybe<Scalars['String']['input']>
  entityVectorNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  entityVectorNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** categories edge predicates */
  hasCategories?: InputMaybe<Scalars['Boolean']['input']>
  hasCategoriesWith?: InputMaybe<Array<PostCategoryWhereInput>>
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']['input']>
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>
  /** liked_by edge predicates */
  hasLikedBy?: InputMaybe<Scalars['Boolean']['input']>
  hasLikedByWith?: InputMaybe<Array<UserWhereInput>>
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']['input']>
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>
  /** saved_by edge predicates */
  hasSavedBy?: InputMaybe<Scalars['Boolean']['input']>
  hasSavedByWith?: InputMaybe<Array<UserWhereInput>>
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>
  idGT?: InputMaybe<Scalars['ID']['input']>
  idGTE?: InputMaybe<Scalars['ID']['input']>
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>
  idLT?: InputMaybe<Scalars['ID']['input']>
  idLTE?: InputMaybe<Scalars['ID']['input']>
  idNEQ?: InputMaybe<Scalars['ID']['input']>
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>
  /** is_moderated field predicates */
  isModerated?: InputMaybe<Scalars['Boolean']['input']>
  isModeratedNEQ?: InputMaybe<Scalars['Boolean']['input']>
  /** link field predicates */
  link?: InputMaybe<Scalars['String']['input']>
  linkContains?: InputMaybe<Scalars['String']['input']>
  linkContainsFold?: InputMaybe<Scalars['String']['input']>
  linkEqualFold?: InputMaybe<Scalars['String']['input']>
  linkGT?: InputMaybe<Scalars['String']['input']>
  linkGTE?: InputMaybe<Scalars['String']['input']>
  linkHasPrefix?: InputMaybe<Scalars['String']['input']>
  linkHasSuffix?: InputMaybe<Scalars['String']['input']>
  linkIn?: InputMaybe<Array<Scalars['String']['input']>>
  linkLT?: InputMaybe<Scalars['String']['input']>
  linkLTE?: InputMaybe<Scalars['String']['input']>
  linkNEQ?: InputMaybe<Scalars['String']['input']>
  linkNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  /** moderation_comment field predicates */
  moderationComment?: InputMaybe<Scalars['String']['input']>
  moderationCommentContains?: InputMaybe<Scalars['String']['input']>
  moderationCommentContainsFold?: InputMaybe<Scalars['String']['input']>
  moderationCommentEqualFold?: InputMaybe<Scalars['String']['input']>
  moderationCommentGT?: InputMaybe<Scalars['String']['input']>
  moderationCommentGTE?: InputMaybe<Scalars['String']['input']>
  moderationCommentHasPrefix?: InputMaybe<Scalars['String']['input']>
  moderationCommentHasSuffix?: InputMaybe<Scalars['String']['input']>
  moderationCommentIn?: InputMaybe<Array<Scalars['String']['input']>>
  moderationCommentIsNil?: InputMaybe<Scalars['Boolean']['input']>
  moderationCommentLT?: InputMaybe<Scalars['String']['input']>
  moderationCommentLTE?: InputMaybe<Scalars['String']['input']>
  moderationCommentNEQ?: InputMaybe<Scalars['String']['input']>
  moderationCommentNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  moderationCommentNotNil?: InputMaybe<Scalars['Boolean']['input']>
  not?: InputMaybe<PostWhereInput>
  or?: InputMaybe<Array<PostWhereInput>>
  /** pinned field predicates */
  pinned?: InputMaybe<Scalars['Boolean']['input']>
  pinnedNEQ?: InputMaybe<Scalars['Boolean']['input']>
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>
  titleContains?: InputMaybe<Scalars['String']['input']>
  titleContainsFold?: InputMaybe<Scalars['String']['input']>
  titleEqualFold?: InputMaybe<Scalars['String']['input']>
  titleGT?: InputMaybe<Scalars['String']['input']>
  titleGTE?: InputMaybe<Scalars['String']['input']>
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>
  titleLT?: InputMaybe<Scalars['String']['input']>
  titleLTE?: InputMaybe<Scalars['String']['input']>
  titleNEQ?: InputMaybe<Scalars['String']['input']>
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
}

export type Query = {
  __typename?: 'Query'
  /** Admin search across all objects */
  adminSearch?: Maybe<SearchResultConnection>
  /** Search across User objects */
  adminUserSearch?: Maybe<UserSearchResult>
  /** Look up apiKey by ID */
  apiKey: ApiKey
  apiKeys: ApiKeyConnection
  /** Look up comment by ID */
  comment: Comment
  comments: CommentConnection
  me?: Maybe<User>
  /** Fetches an object given its ID. */
  node?: Maybe<Node>
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>
  /** Look up post by ID */
  post: Post
  postCategories: PostCategoryConnection
  /** Look up postCategory by ID */
  postCategory: PostCategory
  posts: PostConnection
  /** Search across all objects */
  search?: Maybe<SearchResultConnection>
  /** Look up user by ID */
  user: User
  /** Search across User objects */
  userSearch?: Maybe<UserSearchResult>
  users: UserConnection
}

export type QueryAdminSearchArgs = {
  query: Scalars['String']['input']
}

export type QueryAdminUserSearchArgs = {
  query: Scalars['String']['input']
}

export type QueryApiKeyArgs = {
  id: Scalars['ID']['input']
}

export type QueryApiKeysArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  orderBy?: InputMaybe<ApiKeyOrder>
  where?: InputMaybe<ApiKeyWhereInput>
}

export type QueryCommentArgs = {
  id: Scalars['ID']['input']
}

export type QueryCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  orderBy?: InputMaybe<CommentOrder>
  where?: InputMaybe<CommentWhereInput>
}

export type QueryNodeArgs = {
  id: Scalars['ID']['input']
}

export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>
}

export type QueryPostArgs = {
  id: Scalars['ID']['input']
}

export type QueryPostCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  orderBy?: InputMaybe<PostCategoryOrder>
  where?: InputMaybe<PostCategoryWhereInput>
}

export type QueryPostCategoryArgs = {
  id: Scalars['ID']['input']
}

export type QueryPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  orderBy?: InputMaybe<PostOrder>
  where?: InputMaybe<PostWhereInput>
}

export type QuerySearchArgs = {
  query: Scalars['String']['input']
}

export type QueryUserArgs = {
  id: Scalars['ID']['input']
}

export type QueryUserSearchArgs = {
  query: Scalars['String']['input']
}

export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  orderBy?: InputMaybe<UserOrder>
  where?: InputMaybe<UserWhereInput>
}

export type SearchResult = UserSearchResult

export type SearchResultConnection = {
  __typename?: 'SearchResultConnection'
  /** A list of nodes with results. */
  nodes: Array<SearchResult>
  /** Information to aid in pagination. */
  page: PageInfo
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output']
}

/**
 * UpdateApiKeyInput is used for update ApiKey object.
 * Input was generated by ent.
 */
export type UpdateApiKeyInput = {
  apiKey?: InputMaybe<Scalars['String']['input']>
  expiresOn?: InputMaybe<Scalars['Time']['input']>
}

/**
 * UpdateCommentInput is used for update Comment object.
 * Input was generated by ent.
 */
export type UpdateCommentInput = {
  clearPost?: InputMaybe<Scalars['Boolean']['input']>
  content?: InputMaybe<Scalars['String']['input']>
  ownerID?: InputMaybe<Scalars['ID']['input']>
  postID?: InputMaybe<Scalars['ID']['input']>
}

/**
 * UpdatePostCategoryInput is used for update PostCategory object.
 * Input was generated by ent.
 */
export type UpdatePostCategoryInput = {
  category?: InputMaybe<PostCategoryCategory>
  clearPost?: InputMaybe<Scalars['Boolean']['input']>
  postID?: InputMaybe<Scalars['ID']['input']>
}

/**
 * UpdatePostInput is used for update Post object.
 * Input was generated by ent.
 */
export type UpdatePostInput = {
  addCategoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  addCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  addLikedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  addSavedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  clearCategories?: InputMaybe<Scalars['Boolean']['input']>
  clearComments?: InputMaybe<Scalars['Boolean']['input']>
  clearContent?: InputMaybe<Scalars['Boolean']['input']>
  clearLikedBy?: InputMaybe<Scalars['Boolean']['input']>
  clearModerationComment?: InputMaybe<Scalars['Boolean']['input']>
  clearSavedBy?: InputMaybe<Scalars['Boolean']['input']>
  content?: InputMaybe<Scalars['String']['input']>
  isModerated?: InputMaybe<Scalars['Boolean']['input']>
  link?: InputMaybe<Scalars['String']['input']>
  moderationComment?: InputMaybe<Scalars['String']['input']>
  pinned?: InputMaybe<Scalars['Boolean']['input']>
  removeCategoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  removeCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  removeLikedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  removeSavedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  title?: InputMaybe<Scalars['String']['input']>
}

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  addLikedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  addPublishedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  addSavedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  /** the alias of the user is shown alongside the display name */
  alias?: InputMaybe<Scalars['String']['input']>
  apiKeyID?: InputMaybe<Scalars['ID']['input']>
  appendAwards?: InputMaybe<Array<Scalars['String']['input']>>
  authProvider?: InputMaybe<UserAuthProvider>
  awards?: InputMaybe<Array<Scalars['String']['input']>>
  clearAPIKey?: InputMaybe<Scalars['Boolean']['input']>
  clearAlias?: InputMaybe<Scalars['Boolean']['input']>
  clearAwards?: InputMaybe<Scalars['Boolean']['input']>
  clearComments?: InputMaybe<Scalars['Boolean']['input']>
  clearLastPostSeenCursor?: InputMaybe<Scalars['Boolean']['input']>
  clearLastSeenAt?: InputMaybe<Scalars['Boolean']['input']>
  clearLikedPosts?: InputMaybe<Scalars['Boolean']['input']>
  clearProfileImage?: InputMaybe<Scalars['Boolean']['input']>
  clearPublishedPosts?: InputMaybe<Scalars['Boolean']['input']>
  clearSavedPosts?: InputMaybe<Scalars['Boolean']['input']>
  displayName?: InputMaybe<Scalars['String']['input']>
  /** cursor for last post seen */
  lastPostSeenCursor?: InputMaybe<Scalars['String']['input']>
  /** the time the user was last seen */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>
  profileImage?: InputMaybe<Scalars['String']['input']>
  removeCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  removeLikedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  removePublishedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  removeSavedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>
  /** the role of the user */
  role?: InputMaybe<UserRole>
}

export type User = Node & {
  __typename?: 'User'
  /** the alias of the user is shown alongside the display name */
  alias?: Maybe<Scalars['String']['output']>
  apiKey?: Maybe<ApiKey>
  authProvider: UserAuthProvider
  awards?: Maybe<Array<Scalars['String']['output']>>
  comments?: Maybe<Array<Comment>>
  createdAt: Scalars['Time']['output']
  deletedAt?: Maybe<Scalars['Time']['output']>
  deletedBy?: Maybe<Scalars['String']['output']>
  displayName: Scalars['String']['output']
  id: Scalars['ID']['output']
  /** cursor for last post seen */
  lastPostSeenCursor?: Maybe<Scalars['String']['output']>
  /** the time the user was last seen */
  lastSeenAt?: Maybe<Scalars['Time']['output']>
  likedPosts?: Maybe<Array<Post>>
  profileImage?: Maybe<Scalars['String']['output']>
  publishedPosts?: Maybe<Array<Post>>
  /** the role of the user */
  role: UserRole
  savedPosts?: Maybe<Array<Post>>
  twitchInfo?: Maybe<UserTwitchInfo>
  updatedAt: Scalars['Time']['output']
}

/** UserAuthProvider is enum for the field auth_provider */
export type UserAuthProvider = 'TWITCH'

/** Return response for createBulkUser mutation */
export type UserBulkCreatePayload = {
  __typename?: 'UserBulkCreatePayload'
  /** Created users */
  users?: Maybe<Array<User>>
}

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output']
}

/** Return response for createUser mutation */
export type UserCreatePayload = {
  __typename?: 'UserCreatePayload'
  /** Created user */
  user: User
}

/** Return response for deleteUser mutation */
export type UserDeletePayload = {
  __typename?: 'UserDeletePayload'
  /** Deleted user ID */
  deletedID: Scalars['ID']['output']
}

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output']
  /** The item at the end of the edge. */
  node?: Maybe<User>
}

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection
  /** The field by which to order Users. */
  field: UserOrderField
}

/** Properties by which User connections can be ordered. */
export type UserOrderField = 'CREATED_AT' | 'ID' | 'UPDATED_AT'

/** UserRole is enum for the field role */
export type UserRole = 'ADMIN' | 'GUEST' | 'MODERATOR' | 'USER'

export type UserSearchResult = {
  __typename?: 'UserSearchResult'
  users?: Maybe<Array<User>>
}

export type UserTwitchInfo = {
  __typename?: 'UserTwitchInfo'
  isBanned?: Maybe<Scalars['Boolean']['output']>
  isBroadcaster?: Maybe<Scalars['Boolean']['output']>
  isFollower?: Maybe<Scalars['Boolean']['output']>
  isSubscriber?: Maybe<Scalars['Boolean']['output']>
}

/** Return response for updateUser mutation */
export type UserUpdatePayload = {
  __typename?: 'UserUpdatePayload'
  /** Updated user */
  user: User
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  /** alias field predicates */
  alias?: InputMaybe<Scalars['String']['input']>
  aliasContains?: InputMaybe<Scalars['String']['input']>
  aliasContainsFold?: InputMaybe<Scalars['String']['input']>
  aliasEqualFold?: InputMaybe<Scalars['String']['input']>
  aliasGT?: InputMaybe<Scalars['String']['input']>
  aliasGTE?: InputMaybe<Scalars['String']['input']>
  aliasHasPrefix?: InputMaybe<Scalars['String']['input']>
  aliasHasSuffix?: InputMaybe<Scalars['String']['input']>
  aliasIn?: InputMaybe<Array<Scalars['String']['input']>>
  aliasIsNil?: InputMaybe<Scalars['Boolean']['input']>
  aliasLT?: InputMaybe<Scalars['String']['input']>
  aliasLTE?: InputMaybe<Scalars['String']['input']>
  aliasNEQ?: InputMaybe<Scalars['String']['input']>
  aliasNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  aliasNotNil?: InputMaybe<Scalars['Boolean']['input']>
  and?: InputMaybe<Array<UserWhereInput>>
  /** auth_provider field predicates */
  authProvider?: InputMaybe<UserAuthProvider>
  authProviderIn?: InputMaybe<Array<UserAuthProvider>>
  authProviderNEQ?: InputMaybe<UserAuthProvider>
  authProviderNotIn?: InputMaybe<Array<UserAuthProvider>>
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>
  createdAtGT?: InputMaybe<Scalars['Time']['input']>
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  createdAtLT?: InputMaybe<Scalars['Time']['input']>
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** deleted_by field predicates */
  deletedBy?: InputMaybe<Scalars['String']['input']>
  deletedByContains?: InputMaybe<Scalars['String']['input']>
  deletedByContainsFold?: InputMaybe<Scalars['String']['input']>
  deletedByEqualFold?: InputMaybe<Scalars['String']['input']>
  deletedByGT?: InputMaybe<Scalars['String']['input']>
  deletedByGTE?: InputMaybe<Scalars['String']['input']>
  deletedByHasPrefix?: InputMaybe<Scalars['String']['input']>
  deletedByHasSuffix?: InputMaybe<Scalars['String']['input']>
  deletedByIn?: InputMaybe<Array<Scalars['String']['input']>>
  deletedByIsNil?: InputMaybe<Scalars['Boolean']['input']>
  deletedByLT?: InputMaybe<Scalars['String']['input']>
  deletedByLTE?: InputMaybe<Scalars['String']['input']>
  deletedByNEQ?: InputMaybe<Scalars['String']['input']>
  deletedByNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  deletedByNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** display_name field predicates */
  displayName?: InputMaybe<Scalars['String']['input']>
  displayNameContains?: InputMaybe<Scalars['String']['input']>
  displayNameContainsFold?: InputMaybe<Scalars['String']['input']>
  displayNameEqualFold?: InputMaybe<Scalars['String']['input']>
  displayNameGT?: InputMaybe<Scalars['String']['input']>
  displayNameGTE?: InputMaybe<Scalars['String']['input']>
  displayNameHasPrefix?: InputMaybe<Scalars['String']['input']>
  displayNameHasSuffix?: InputMaybe<Scalars['String']['input']>
  displayNameIn?: InputMaybe<Array<Scalars['String']['input']>>
  displayNameLT?: InputMaybe<Scalars['String']['input']>
  displayNameLTE?: InputMaybe<Scalars['String']['input']>
  displayNameNEQ?: InputMaybe<Scalars['String']['input']>
  displayNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  /** api_key edge predicates */
  hasAPIKey?: InputMaybe<Scalars['Boolean']['input']>
  hasAPIKeyWith?: InputMaybe<Array<ApiKeyWhereInput>>
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']['input']>
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>
  /** liked_posts edge predicates */
  hasLikedPosts?: InputMaybe<Scalars['Boolean']['input']>
  hasLikedPostsWith?: InputMaybe<Array<PostWhereInput>>
  /** published_posts edge predicates */
  hasPublishedPosts?: InputMaybe<Scalars['Boolean']['input']>
  hasPublishedPostsWith?: InputMaybe<Array<PostWhereInput>>
  /** saved_posts edge predicates */
  hasSavedPosts?: InputMaybe<Scalars['Boolean']['input']>
  hasSavedPostsWith?: InputMaybe<Array<PostWhereInput>>
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>
  idGT?: InputMaybe<Scalars['ID']['input']>
  idGTE?: InputMaybe<Scalars['ID']['input']>
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>
  idLT?: InputMaybe<Scalars['ID']['input']>
  idLTE?: InputMaybe<Scalars['ID']['input']>
  idNEQ?: InputMaybe<Scalars['ID']['input']>
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>
  /** last_post_seen_cursor field predicates */
  lastPostSeenCursor?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorContains?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorContainsFold?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorEqualFold?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorGT?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorGTE?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorHasPrefix?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorHasSuffix?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorIn?: InputMaybe<Array<Scalars['String']['input']>>
  lastPostSeenCursorIsNil?: InputMaybe<Scalars['Boolean']['input']>
  lastPostSeenCursorLT?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorLTE?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorNEQ?: InputMaybe<Scalars['String']['input']>
  lastPostSeenCursorNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  lastPostSeenCursorNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** last_seen_at field predicates */
  lastSeenAt?: InputMaybe<Scalars['Time']['input']>
  lastSeenAtGT?: InputMaybe<Scalars['Time']['input']>
  lastSeenAtGTE?: InputMaybe<Scalars['Time']['input']>
  lastSeenAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  lastSeenAtIsNil?: InputMaybe<Scalars['Boolean']['input']>
  lastSeenAtLT?: InputMaybe<Scalars['Time']['input']>
  lastSeenAtLTE?: InputMaybe<Scalars['Time']['input']>
  lastSeenAtNEQ?: InputMaybe<Scalars['Time']['input']>
  lastSeenAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
  lastSeenAtNotNil?: InputMaybe<Scalars['Boolean']['input']>
  not?: InputMaybe<UserWhereInput>
  or?: InputMaybe<Array<UserWhereInput>>
  /** profile_image field predicates */
  profileImage?: InputMaybe<Scalars['String']['input']>
  profileImageContains?: InputMaybe<Scalars['String']['input']>
  profileImageContainsFold?: InputMaybe<Scalars['String']['input']>
  profileImageEqualFold?: InputMaybe<Scalars['String']['input']>
  profileImageGT?: InputMaybe<Scalars['String']['input']>
  profileImageGTE?: InputMaybe<Scalars['String']['input']>
  profileImageHasPrefix?: InputMaybe<Scalars['String']['input']>
  profileImageHasSuffix?: InputMaybe<Scalars['String']['input']>
  profileImageIn?: InputMaybe<Array<Scalars['String']['input']>>
  profileImageIsNil?: InputMaybe<Scalars['Boolean']['input']>
  profileImageLT?: InputMaybe<Scalars['String']['input']>
  profileImageLTE?: InputMaybe<Scalars['String']['input']>
  profileImageNEQ?: InputMaybe<Scalars['String']['input']>
  profileImageNotIn?: InputMaybe<Array<Scalars['String']['input']>>
  profileImageNotNil?: InputMaybe<Scalars['Boolean']['input']>
  /** role field predicates */
  role?: InputMaybe<UserRole>
  roleIn?: InputMaybe<Array<UserRole>>
  roleNEQ?: InputMaybe<UserRole>
  roleNotIn?: InputMaybe<Array<UserRole>>
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>
}

export type PaginationFragmentFragment = {
  __typename?: 'PageInfo'
  hasNextPage: boolean
  hasPreviousPage: boolean
  startCursor?: any | null
  endCursor?: any | null
}

export type PostFragment = {
  __typename?: 'Post'
  id: string
  title: string
  content?: string | null
  link: string
  isModerated: boolean
  moderationComment?: string | null
  createdAt: any
  updatedAt: any
  owner: {
    __typename?: 'User'
    id: string
    alias?: string | null
    displayName: string
    awards?: Array<string> | null
    profileImage?: string | null
  }
  likedBy: { __typename?: 'UserConnection'; totalCount: number }
  comments: { __typename?: 'CommentConnection'; totalCount: number }
  categories?: Array<{ __typename?: 'PostCategory'; id: string; category: PostCategoryCategory }> | null
}

export type UserFragment = {
  __typename?: 'User'
  id: string
  role: UserRole
  displayName: string
  profileImage?: string | null
  alias?: string | null
  awards?: Array<string> | null
  lastPostSeenCursor?: string | null
}

export type PostsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<PostWhereInput>
  orderBy?: InputMaybe<PostOrder>
}>

export type PostsQuery = {
  __typename?: 'Query'
  posts: {
    __typename?: 'PostConnection'
    totalCount: number
    pageInfo: {
      __typename?: 'PageInfo'
      hasNextPage: boolean
      hasPreviousPage: boolean
      startCursor?: any | null
      endCursor?: any | null
    }
    edges?: Array<{
      __typename?: 'PostEdge'
      cursor: any
      node?: {
        __typename?: 'Post'
        id: string
        title: string
        content?: string | null
        link: string
        isModerated: boolean
        moderationComment?: string | null
        createdAt: any
        updatedAt: any
        owner: {
          __typename?: 'User'
          id: string
          alias?: string | null
          displayName: string
          awards?: Array<string> | null
          profileImage?: string | null
        }
        likedBy: { __typename?: 'UserConnection'; totalCount: number }
        comments: { __typename?: 'CommentConnection'; totalCount: number }
        categories?: Array<{ __typename?: 'PostCategory'; id: string; category: PostCategoryCategory }> | null
      } | null
    } | null> | null
  }
}

export type PinnedPostsQueryVariables = Exact<{ [key: string]: never }>

export type PinnedPostsQuery = {
  __typename?: 'Query'
  posts: {
    __typename?: 'PostConnection'
    pageInfo: {
      __typename?: 'PageInfo'
      hasNextPage: boolean
      hasPreviousPage: boolean
      startCursor?: any | null
      endCursor?: any | null
    }
    edges?: Array<{
      __typename?: 'PostEdge'
      cursor: any
      node?: {
        __typename?: 'Post'
        id: string
        title: string
        content?: string | null
        link: string
        isModerated: boolean
        moderationComment?: string | null
        createdAt: any
        updatedAt: any
        owner: {
          __typename?: 'User'
          id: string
          alias?: string | null
          displayName: string
          awards?: Array<string> | null
          profileImage?: string | null
        }
        likedBy: { __typename?: 'UserConnection'; totalCount: number }
        comments: { __typename?: 'CommentConnection'; totalCount: number }
        categories?: Array<{ __typename?: 'PostCategory'; id: string; category: PostCategoryCategory }> | null
      } | null
    } | null> | null
  }
}

export type UpdatePostMutationVariables = Exact<{
  id: Scalars['ID']['input']
  input: UpdatePostInput
}>

export type UpdatePostMutation = {
  __typename?: 'Mutation'
  updatePost: {
    __typename?: 'PostUpdatePayload'
    post: {
      __typename?: 'Post'
      id: string
      title: string
      content?: string | null
      link: string
      isModerated: boolean
      moderationComment?: string | null
      createdAt: any
      updatedAt: any
      owner: {
        __typename?: 'User'
        id: string
        alias?: string | null
        displayName: string
        awards?: Array<string> | null
        profileImage?: string | null
      }
      likedBy: { __typename?: 'UserConnection'; totalCount: number }
      comments: { __typename?: 'CommentConnection'; totalCount: number }
      categories?: Array<{ __typename?: 'PostCategory'; id: string; category: PostCategoryCategory }> | null
    }
  }
}

export type CreatePostMutationVariables = Exact<{
  input: CreatePostWithCategoriesInput
}>

export type CreatePostMutation = {
  __typename?: 'Mutation'
  createPostWithCategories: {
    __typename?: 'PostCreatePayload'
    post: {
      __typename?: 'Post'
      id: string
      title: string
      content?: string | null
      link: string
      isModerated: boolean
      moderationComment?: string | null
      createdAt: any
      updatedAt: any
      owner: {
        __typename?: 'User'
        id: string
        alias?: string | null
        displayName: string
        awards?: Array<string> | null
        profileImage?: string | null
      }
      likedBy: { __typename?: 'UserConnection'; totalCount: number }
      comments: { __typename?: 'CommentConnection'; totalCount: number }
      categories?: Array<{ __typename?: 'PostCategory'; id: string; category: PostCategoryCategory }> | null
    }
  }
}

export type CreatePostCategoryMutationVariables = Exact<{
  input: CreatePostCategoryInput
}>

export type CreatePostCategoryMutation = {
  __typename?: 'Mutation'
  createPostCategory: {
    __typename?: 'PostCategoryCreatePayload'
    postCategory: { __typename?: 'PostCategory'; id: string; category: PostCategoryCategory }
  }
}

export type DeletePostCategoryMutationVariables = Exact<{
  id: Scalars['ID']['input']
}>

export type DeletePostCategoryMutation = {
  __typename?: 'Mutation'
  deletePostCategory: { __typename?: 'PostCategoryDeletePayload'; deletedID: string }
}

export type DeletePostMutationVariables = Exact<{
  deletePostId: Scalars['ID']['input']
}>

export type DeletePostMutation = {
  __typename?: 'Mutation'
  deletePost: { __typename?: 'PostDeletePayload'; deletedID: string }
}

export type MeQueryVariables = Exact<{ [key: string]: never }>

export type MeQuery = {
  __typename?: 'Query'
  me?: {
    __typename?: 'User'
    id: string
    role: UserRole
    displayName: string
    profileImage?: string | null
    alias?: string | null
    awards?: Array<string> | null
    lastPostSeenCursor?: string | null
    savedPosts?: Array<{ __typename?: 'Post'; id: string }> | null
    likedPosts?: Array<{ __typename?: 'Post'; id: string }> | null
    publishedPosts?: Array<{ __typename?: 'Post'; id: string }> | null
    twitchInfo?: {
      __typename?: 'UserTwitchInfo'
      isSubscriber?: boolean | null
      isFollower?: boolean | null
      isBroadcaster?: boolean | null
      isBanned?: boolean | null
    } | null
  } | null
}

export type UsersQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  before?: InputMaybe<Scalars['Cursor']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<UserWhereInput>
  orderBy?: InputMaybe<UserOrder>
}>

export type UsersQuery = {
  __typename?: 'Query'
  users: {
    __typename?: 'UserConnection'
    totalCount: number
    pageInfo: {
      __typename?: 'PageInfo'
      hasNextPage: boolean
      hasPreviousPage: boolean
      startCursor?: any | null
      endCursor?: any | null
    }
    edges?: Array<{
      __typename?: 'UserEdge'
      cursor: any
      node?: {
        __typename?: 'User'
        id: string
        role: UserRole
        displayName: string
        profileImage?: string | null
        alias?: string | null
        awards?: Array<string> | null
        lastPostSeenCursor?: string | null
      } | null
    } | null> | null
  }
}

export type UpdateUserAuthMutationVariables = Exact<{
  id: Scalars['ID']['input']
  role?: InputMaybe<UserRole>
  awards?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>
}>

export type UpdateUserAuthMutation = {
  __typename?: 'Mutation'
  updateUser: {
    __typename?: 'UserUpdatePayload'
    user: {
      __typename?: 'User'
      id: string
      role: UserRole
      displayName: string
      profileImage?: string | null
      alias?: string | null
      awards?: Array<string> | null
      lastPostSeenCursor?: string | null
    }
  }
}

export type UpdateUserMutationVariables = Exact<{
  id: Scalars['ID']['input']
  input: UpdateUserInput
}>

export type UpdateUserMutation = {
  __typename?: 'Mutation'
  updateUser: {
    __typename?: 'UserUpdatePayload'
    user: {
      __typename?: 'User'
      id: string
      role: UserRole
      displayName: string
      profileImage?: string | null
      alias?: string | null
      awards?: Array<string> | null
      lastPostSeenCursor?: string | null
    }
  }
}

export const PaginationFragmentFragmentDoc = gql`
  fragment PaginationFragment on PageInfo {
    hasNextPage
    hasPreviousPage
    startCursor
    endCursor
  }
`
export const PostFragmentDoc = gql`
  fragment Post on Post {
    id
    title
    content
    link
    owner {
      id
      alias
      displayName
      awards
      profileImage
    }
    likedBy {
      totalCount
    }
    comments {
      totalCount
    }
    isModerated
    moderationComment
    categories {
      id
      category
    }
    createdAt
    updatedAt
  }
`
export const UserFragmentDoc = gql`
  fragment User on User {
    id
    role
    displayName
    profileImage
    alias
    awards
    lastPostSeenCursor
  }
`
export const PostsDocument = gql`
  query Posts($after: Cursor, $first: Int, $before: Cursor, $last: Int, $where: PostWhereInput, $orderBy: PostOrder) {
    posts(after: $after, first: $first, before: $before, last: $last, where: $where, orderBy: $orderBy) {
      pageInfo {
        ...PaginationFragment
      }
      edges {
        cursor
        node {
          ...Post
        }
      }
      totalCount
    }
  }
  ${PaginationFragmentFragmentDoc}
  ${PostFragmentDoc}
`

export const PostsComponent = (
  props: Omit<Urql.QueryProps<PostsQuery, PostsQueryVariables>, 'query'> & { variables?: PostsQueryVariables },
) => <Urql.Query {...props} query={PostsDocument} />

export function usePostsQuery(options?: Omit<Urql.UseQueryArgs<PostsQueryVariables>, 'query'>) {
  return Urql.useQuery<PostsQuery, PostsQueryVariables>({ query: PostsDocument, ...options })
}
export const PinnedPostsDocument = gql`
  query PinnedPosts {
    posts(where: { pinned: true }) {
      pageInfo {
        ...PaginationFragment
      }
      edges {
        cursor
        node {
          ...Post
        }
      }
    }
  }
  ${PaginationFragmentFragmentDoc}
  ${PostFragmentDoc}
`

export const PinnedPostsComponent = (
  props: Omit<Urql.QueryProps<PinnedPostsQuery, PinnedPostsQueryVariables>, 'query'> & {
    variables?: PinnedPostsQueryVariables
  },
) => <Urql.Query {...props} query={PinnedPostsDocument} />

export function usePinnedPostsQuery(options?: Omit<Urql.UseQueryArgs<PinnedPostsQueryVariables>, 'query'>) {
  return Urql.useQuery<PinnedPostsQuery, PinnedPostsQueryVariables>({ query: PinnedPostsDocument, ...options })
}
export const UpdatePostDocument = gql`
  mutation UpdatePost($id: ID!, $input: UpdatePostInput!) {
    updatePost(id: $id, input: $input) {
      post {
        ...Post
      }
    }
  }
  ${PostFragmentDoc}
`

export const UpdatePostComponent = (
  props: Omit<Urql.MutationProps<UpdatePostMutation, UpdatePostMutationVariables>, 'query'> & {
    variables?: UpdatePostMutationVariables
  },
) => <Urql.Mutation {...props} query={UpdatePostDocument} />

export function useUpdatePostMutation() {
  return Urql.useMutation<UpdatePostMutation, UpdatePostMutationVariables>(UpdatePostDocument)
}
export const CreatePostDocument = gql`
  mutation CreatePost($input: CreatePostWithCategoriesInput!) {
    createPostWithCategories(input: $input) {
      post {
        ...Post
      }
    }
  }
  ${PostFragmentDoc}
`

export const CreatePostComponent = (
  props: Omit<Urql.MutationProps<CreatePostMutation, CreatePostMutationVariables>, 'query'> & {
    variables?: CreatePostMutationVariables
  },
) => <Urql.Mutation {...props} query={CreatePostDocument} />

export function useCreatePostMutation() {
  return Urql.useMutation<CreatePostMutation, CreatePostMutationVariables>(CreatePostDocument)
}
export const CreatePostCategoryDocument = gql`
  mutation CreatePostCategory($input: CreatePostCategoryInput!) {
    createPostCategory(input: $input) {
      postCategory {
        id
        category
      }
    }
  }
`

export const CreatePostCategoryComponent = (
  props: Omit<Urql.MutationProps<CreatePostCategoryMutation, CreatePostCategoryMutationVariables>, 'query'> & {
    variables?: CreatePostCategoryMutationVariables
  },
) => <Urql.Mutation {...props} query={CreatePostCategoryDocument} />

export function useCreatePostCategoryMutation() {
  return Urql.useMutation<CreatePostCategoryMutation, CreatePostCategoryMutationVariables>(CreatePostCategoryDocument)
}
export const DeletePostCategoryDocument = gql`
  mutation DeletePostCategory($id: ID!) {
    deletePostCategory(id: $id) {
      deletedID
    }
  }
`

export const DeletePostCategoryComponent = (
  props: Omit<Urql.MutationProps<DeletePostCategoryMutation, DeletePostCategoryMutationVariables>, 'query'> & {
    variables?: DeletePostCategoryMutationVariables
  },
) => <Urql.Mutation {...props} query={DeletePostCategoryDocument} />

export function useDeletePostCategoryMutation() {
  return Urql.useMutation<DeletePostCategoryMutation, DeletePostCategoryMutationVariables>(DeletePostCategoryDocument)
}
export const DeletePostDocument = gql`
  mutation DeletePost($deletePostId: ID!) {
    deletePost(id: $deletePostId) {
      deletedID
    }
  }
`

export const DeletePostComponent = (
  props: Omit<Urql.MutationProps<DeletePostMutation, DeletePostMutationVariables>, 'query'> & {
    variables?: DeletePostMutationVariables
  },
) => <Urql.Mutation {...props} query={DeletePostDocument} />

export function useDeletePostMutation() {
  return Urql.useMutation<DeletePostMutation, DeletePostMutationVariables>(DeletePostDocument)
}
export const MeDocument = gql`
  query Me {
    me {
      ...User
      savedPosts {
        id
      }
      likedPosts {
        id
      }
      publishedPosts {
        id
      }
      lastPostSeenCursor
      twitchInfo {
        isSubscriber
        isFollower
        isBroadcaster
        isBanned
      }
    }
  }
  ${UserFragmentDoc}
`

export const MeComponent = (
  props: Omit<Urql.QueryProps<MeQuery, MeQueryVariables>, 'query'> & { variables?: MeQueryVariables },
) => <Urql.Query {...props} query={MeDocument} />

export function useMeQuery(options?: Omit<Urql.UseQueryArgs<MeQueryVariables>, 'query'>) {
  return Urql.useQuery<MeQuery, MeQueryVariables>({ query: MeDocument, ...options })
}
export const UsersDocument = gql`
  query Users($after: Cursor, $first: Int, $before: Cursor, $last: Int, $where: UserWhereInput, $orderBy: UserOrder) {
    users(after: $after, first: $first, before: $before, last: $last, where: $where, orderBy: $orderBy) {
      pageInfo {
        ...PaginationFragment
      }
      edges {
        cursor
        node {
          ...User
        }
      }
      totalCount
    }
  }
  ${PaginationFragmentFragmentDoc}
  ${UserFragmentDoc}
`

export const UsersComponent = (
  props: Omit<Urql.QueryProps<UsersQuery, UsersQueryVariables>, 'query'> & { variables?: UsersQueryVariables },
) => <Urql.Query {...props} query={UsersDocument} />

export function useUsersQuery(options?: Omit<Urql.UseQueryArgs<UsersQueryVariables>, 'query'>) {
  return Urql.useQuery<UsersQuery, UsersQueryVariables>({ query: UsersDocument, ...options })
}
export const UpdateUserAuthDocument = gql`
  mutation UpdateUserAuth($id: ID!, $role: UserRole, $awards: [String!]) {
    updateUser(id: $id, input: { role: $role, awards: $awards }) {
      user {
        ...User
      }
    }
  }
  ${UserFragmentDoc}
`

export const UpdateUserAuthComponent = (
  props: Omit<Urql.MutationProps<UpdateUserAuthMutation, UpdateUserAuthMutationVariables>, 'query'> & {
    variables?: UpdateUserAuthMutationVariables
  },
) => <Urql.Mutation {...props} query={UpdateUserAuthDocument} />

export function useUpdateUserAuthMutation() {
  return Urql.useMutation<UpdateUserAuthMutation, UpdateUserAuthMutationVariables>(UpdateUserAuthDocument)
}
export const UpdateUserDocument = gql`
  mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
    updateUser(id: $id, input: $input) {
      user {
        ...User
      }
    }
  }
  ${UserFragmentDoc}
`

export const UpdateUserComponent = (
  props: Omit<Urql.MutationProps<UpdateUserMutation, UpdateUserMutationVariables>, 'query'> & {
    variables?: UpdateUserMutationVariables
  },
) => <Urql.Mutation {...props} query={UpdateUserDocument} />

export function useUpdateUserMutation() {
  return Urql.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(UpdateUserDocument)
}
