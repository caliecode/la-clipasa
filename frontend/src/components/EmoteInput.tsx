import React, { useState, useRef, useEffect, useCallback } from 'react'
import {
  Popover,
  Image,
  Text,
  MantineSize,
  Input,
  Loader,
  Box,
  MantineTheme,
  useMantineTheme,
  useMantineColorScheme,
} from '@mantine/core'
import { useWindowEvent } from '@mantine/hooks'
import { EMOTES } from 'src/assets/img/emotes'
import { useTranslation } from 'react-i18next'
import styles from './EmoteInput.module.css'

const EMOTE_IMG_SIZE = 24
/**
 * Converts HTML string within the contentEditable to plain text,
 * replacing emote images with their alt text (emote code).
 */
function htmlToText(html: string): string {
  const tempDiv = document.createElement('div')
  tempDiv.innerHTML = html

  let text = ''
  tempDiv.childNodes.forEach((node) => {
    if (
      node.nodeType === Node.ELEMENT_NODE &&
      (node as HTMLElement).tagName === 'IMG' &&
      (node as HTMLImageElement).dataset.emote === 'true'
    ) {
      text += (node as HTMLImageElement).alt
    } else if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent
    } else if (node.nodeType === Node.ELEMENT_NODE && (node as HTMLElement).tagName === 'BR') {
    } else {
      text += node.textContent
    }
  })

  return text.replace(/\s+/g, ' ').trim()
}

/**
 * Creates the HTML string for an emote image.
 * Includes data attributes, alt text, and styling.
 * Adds a zero-width space AFTER the image to help with cursor placement.
 */
const createEmoteImgHtml = (key: string, src: string): string => {
  return `<img src="${src}" alt="${key}" title="${key}" data-emote="true" contenteditable="false" style="width: ${EMOTE_IMG_SIZE}px; height: ${EMOTE_IMG_SIZE}px; vertical-align: middle; margin: 0 1px;" />â€‹`
}

/**
 * Converts plain text to an HTML string, replacing known emote codes
 * with their corresponding image HTML generated by createEmoteImgHtml.
 * Uses a case-insensitive search but preserves original case for display if needed (using alt).
 */
function textToHtml(text: string): string {
  const emoteKeys = Object.keys(EMOTES)
  if (emoteKeys.length === 0) return text

  const escapedKeys = emoteKeys.map((key) => key.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'))

  const regex = new RegExp(`\\b(${escapedKeys.join('|')})\\b`, 'gi')

  return text.replace(regex, (match) => {
    const lowerMatch = match.toLowerCase()
    const foundEntry = Object.entries(EMOTES).find(([key]) => key.toLowerCase() === lowerMatch)

    if (foundEntry) {
      const [canonicalKey, src] = foundEntry
      return createEmoteImgHtml(canonicalKey, src)
    }
    return match
  })
}

const POTENTIAL_EMOTE_REGEX_END = /(\bcalie[a-z0-9]*)$/i

/**
 * Finds a potential emote text pattern right before the cursor in a container node.
 * Returns the matched text and a Range object spanning that text.
 */
const findPotentialEmoteAtCursor = (container: Node): { text: string; range: Range } | null => {
  const sel = window.getSelection()
  if (!sel || sel.rangeCount === 0 || !sel.isCollapsed) {
    return null
  }

  const range = sel.getRangeAt(0)

  const preCaretRange = range.cloneRange()
  preCaretRange.selectNodeContents(container)
  try {
    preCaretRange.setEnd(range.startContainer, range.startOffset)
  } catch (e) {
    console.error('Error setting range end:', e, range.startContainer, range.startOffset)
    return null
  }
  const textBeforeCursor = preCaretRange.toString()

  if (!textBeforeCursor) return null

  const match = textBeforeCursor.match(POTENTIAL_EMOTE_REGEX_END)

  if (match && match[1]) {
    const potentialName = match[1]
    const lowerPotentialName = potentialName.toLowerCase()
    const knownEmotesLower = Object.keys(EMOTES).map((k) => k.toLowerCase())

    if (knownEmotesLower.some((known) => known.startsWith(lowerPotentialName))) {
      const potentialRange = range.cloneRange()
      try {
        potentialRange.setStart(range.startContainer, range.startOffset - potentialName.length)

        if (container.contains(potentialRange.commonAncestorContainer)) {
          if (potentialRange.toString() === potentialName) {
            return {
              text: potentialName,
              range: potentialRange,
            }
          } else {
            console.warn(
              'Range text mismatch, likely due to complex node structure.',
              potentialRange.toString(),
              potentialName,
            )
          }
        }
      } catch (e) {
        console.error('Error adjusting range for potential emote:', e)
      }
    }
  }

  return null
}

const findAllMatchingEmotes = (potentialText: string): { key: string; src: string }[] => {
  if (!potentialText) return []
  const lowerPotential = potentialText.toLowerCase()
  return Object.entries(EMOTES)
    .filter(([key]) => key.toLowerCase().startsWith(lowerPotential))
    .map(([key, src]) => ({ key, src }))

    .sort((a, b) => a.key.localeCompare(b.key))
}

function moveCursorToEnd(element: HTMLElement) {
  const range = document.createRange()
  const sel = window.getSelection()
  range.selectNodeContents(element)
  range.collapse(false)
  sel?.removeAllRanges()
  sel?.addRange(range)
  //element.focus();
}

interface EmoteInputProps
  extends Omit<React.ComponentPropsWithoutRef<typeof Input.Wrapper>, 'onChange' | 'children' | 'value'> {
  value?: string
  onChange: (value: string) => void
  size?: MantineSize | string
  placeholder?: string
  disabled?: boolean
  error?: React.ReactNode
}

export function EmoteInput({
  value = '',
  onChange,
  size = 'sm',
  placeholder,
  disabled,
  error,
  ...props
}: EmoteInputProps) {
  const { t } = useTranslation()
  const theme = useMantineTheme()
  const contentEditableRef = useRef<HTMLDivElement>(null)
  const popoverRef = useRef<HTMLDivElement>(null)
  const [popoverOpened, setPopoverOpened] = useState(false)
  const [suggestions, setSuggestions] = useState<{ key: string; src: string }[]>([])
  const [selectedSuggestionIndex, setSelectedSuggestionIndex] = useState(0)

  const [potentialEmoteInfo, setPotentialEmoteInfo] = useState<{ text: string; range: Range } | null>(null)

  const isComposing = useRef(false)

  const isExternalUpdate = useRef(false)

  useEffect(() => {
    if (!contentEditableRef.current) return

    const currentInternalText = htmlToText(contentEditableRef.current.innerHTML)

    if (value !== currentInternalText && !isComposing.current) {
      isExternalUpdate.current = true
      const newHtml = textToHtml(value)
      contentEditableRef.current.innerHTML = newHtml

      if (document.activeElement === contentEditableRef.current) {
        moveCursorToEnd(contentEditableRef.current)
      }

      setShowPlaceholder(!htmlToText(newHtml).trim())

      setTimeout(() => {
        isExternalUpdate.current = false
      }, 0)
    }
  }, [value])

  useEffect(() => {
    if (contentEditableRef.current) {
      const initialHtml = textToHtml(value)
      contentEditableRef.current.innerHTML = initialHtml

      setShowPlaceholder(!htmlToText(initialHtml).trim())
    }
  }, [])

  const updateSuggestions = useCallback(() => {
    if (!contentEditableRef.current || isComposing.current) {
      return
    }

    const potential = findPotentialEmoteAtCursor(contentEditableRef.current)

    if (potential) {
      const matches = findAllMatchingEmotes(potential.text)
      if (matches.length > 0) {
        setSuggestions(matches)
        setSelectedSuggestionIndex(0)
        setPotentialEmoteInfo(potential)
        setPopoverOpened(true)
      } else {
        closePopover()
      }
    } else {
      closePopover()
    }
  }, [])

  const closePopover = useCallback(() => {
    setPopoverOpened(false)

    setSelectedSuggestionIndex(0)
    setPotentialEmoteInfo(null)
  }, [])

  const handleInput = useCallback(
    (event: React.SyntheticEvent<HTMLDivElement>) => {
      if (isComposing.current || isExternalUpdate.current) {
        if (isExternalUpdate.current) {
        }
        return
      }

      if (!contentEditableRef.current) return

      const currentHtml = event.currentTarget.innerHTML
      const currentText = htmlToText(currentHtml)

      onChange(currentText)

      updateSuggestions()

      setShowPlaceholder(!currentText.trim())
    },
    [onChange, updateSuggestions],
  )

  const insertEmote = useCallback(
    (emote: { key: string; src: string }) => {
      if (!contentEditableRef.current || !potentialEmoteInfo) {
        console.error('Cannot insert emote, missing ref or potential info')
        return
      }

      const { range } = potentialEmoteInfo
      const emoteHtml = createEmoteImgHtml(emote.key, emote.src)

      const sel = window.getSelection()
      if (!sel) return

      range.deleteContents()

      const el = document.createElement('div')
      el.innerHTML = emoteHtml
      const frag = document.createDocumentFragment()
      let node, lastNode
      while ((node = el.firstChild)) {
        lastNode = frag.appendChild(node)
      }

      range.insertNode(frag)

      if (lastNode) {
        const newRange = document.createRange()
        newRange.setStartAfter(lastNode)
        newRange.collapse(true)

        sel.removeAllRanges()
        sel.addRange(newRange)
      }

      const newHtml = contentEditableRef.current.innerHTML
      const newText = htmlToText(newHtml)
      onChange(newText)

      closePopover()
      contentEditableRef.current.focus()

      setShowPlaceholder(!newText.trim())
    },
    [potentialEmoteInfo, onChange, closePopover],
  )

  const handleKeyDown = useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (isComposing.current) return

      if (popoverOpened && suggestions.length > 0) {
        if (event.key === 'Enter') {
          event.preventDefault()
          const selectedEmote = suggestions[selectedSuggestionIndex]
          if (selectedEmote) {
            insertEmote(selectedEmote)
          }
        } else if (event.key === 'Tab' || event.key === 'ArrowDown') {
          event.preventDefault()
          const nextIndex = (selectedSuggestionIndex + 1) % suggestions.length
          setSelectedSuggestionIndex(nextIndex)
        } else if (event.key === 'ArrowUp') {
          event.preventDefault()
          const prevIndex = (selectedSuggestionIndex - 1 + suggestions.length) % suggestions.length
          setSelectedSuggestionIndex(prevIndex)
        } else if (event.key === 'Escape') {
          event.preventDefault()
          closePopover()
        } else if (['ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(event.key)) {
          setTimeout(updateSuggestions, 0)
        }
      }

      if (event.key === 'Backspace') {
        const sel = window.getSelection()
        if (sel && sel.isCollapsed && contentEditableRef.current) {
          const range = sel.getRangeAt(0)

          let nodeToDelete: Node | null = null

          if (range.startOffset > 0) {
            const nodeBeforeCursor = range.startContainer.childNodes[range.startOffset - 1]
            if (
              nodeBeforeCursor &&
              nodeBeforeCursor.nodeName === 'IMG' &&
              (nodeBeforeCursor as HTMLElement).dataset.emote === 'true'
            ) {
              nodeToDelete = nodeBeforeCursor
            }
          } else if (range.startContainer.previousSibling) {
            if (
              range.startContainer.previousSibling.nodeName === 'IMG' &&
              (range.startContainer.previousSibling as HTMLElement).dataset.emote === 'true'
            ) {
              nodeToDelete = range.startContainer.previousSibling
            }
          }

          if (nodeToDelete) {
            event.preventDefault()

            const parent = nodeToDelete.parentNode

            const spaceAfter = nodeToDelete.nextSibling
            if (
              spaceAfter &&
              spaceAfter.nodeType === Node.TEXT_NODE &&
              (spaceAfter.textContent === ' ' || spaceAfter.textContent === '\u200B')
            ) {
              parent?.removeChild(spaceAfter)
            }

            parent?.removeChild(nodeToDelete)

            handleInput({ currentTarget: contentEditableRef.current } as React.SyntheticEvent<HTMLDivElement>)
          }
        }
      }
    },
    [popoverOpened, suggestions, selectedSuggestionIndex, insertEmote, closePopover, updateSuggestions, handleInput],
  )

  const handleCompositionStart = useCallback(() => {
    isComposing.current = true
  }, [])

  const handleCompositionEnd = useCallback(
    (event: React.CompositionEvent<HTMLDivElement>) => {
      isComposing.current = false

      handleInput(event)
    },
    [handleInput],
  )

  useWindowEvent('click', (event) => {
    if (
      popoverOpened &&
      popoverRef.current &&
      !popoverRef.current.contains(event.target as Node) &&
      !contentEditableRef.current?.contains(event.target as Node)
    ) {
      closePopover()
    }
  })

  const [showPlaceholder, setShowPlaceholder] = useState(true)

  const checkPlaceholder = useCallback(() => {
    if (contentEditableRef.current) {
      const textContent = htmlToText(contentEditableRef.current.innerHTML)
      setShowPlaceholder(!textContent.trim())
    }
  }, [])

  const computedPlaceholder =
    placeholder && showPlaceholder ? (
      <Text
        size={size}
        c="dimmed"
        className={styles.placeholder}
        style={{
          paddingTop: `var(--_input-padding-y, ${theme.spacing.xs})`,
          paddingBottom: `var(--_input-padding-y, ${theme.spacing.xs})`,
          paddingLeft: `var(--_input-padding-x, ${theme.spacing.sm})`,
          paddingRight: `var(--_input-padding-x, ${theme.spacing.sm})`,
          pointerEvents: 'none',
          position: 'absolute',
          top: 0,
          left: 0,
          lineHeight: theme.lineHeights.md,
          fontSize: `var(--input-font-size, ${theme.fontSizes[size as keyof MantineTheme['fontSizes']] ?? theme.fontSizes.sm})`,
          zIndex: 0,
        }}
      >
        {placeholder}
      </Text>
    ) : null

  const inputPadding = theme.spacing[size as keyof MantineTheme['spacing']] ?? theme.spacing.sm
  const inputFontSize = theme.fontSizes[size as keyof MantineTheme['fontSizes']] ?? theme.fontSizes.sm

  const { colorScheme } = useMantineColorScheme()

  return (
    <Input.Wrapper {...props} size={size} error={error}>
      <Popover
        opened={popoverOpened && suggestions.length > 0}
        position="bottom-start"
        withinPortal
        shadow="md"
        trapFocus={false}
        offset={5}
        disabled={suggestions.length === 0}
        transitionProps={{ transition: 'pop', duration: 100 }}
        zIndex={1000}
      >
        <Popover.Target>
          <Box
            component="div"
            className={styles.contentEditableWrapper}
            data-with-error={!!error}
            mod={{ disabled }}
            style={{
              position: 'relative',
              border: `1px solid ${error ? theme.colors.red[6] : colorScheme === 'dark' ? theme.colors.dark[4] : theme.colors.gray[4]}`,
              borderRadius: theme.radius.sm,
              padding: 0,
              backgroundColor: colorScheme === 'dark' ? theme.colors.dark[6] : 'white',
              cursor: disabled ? 'not-allowed' : 'text',
              '&:focus-within': {
                borderColor: error ? theme.colors.red[6] : theme.primaryColor[6],
                boxShadow: error ? undefined : `0 0 0 1px ${theme.primaryColor[6]}`,
              },

              opacity: disabled ? 0.6 : 1,
            }}
            onClick={() => !disabled && contentEditableRef.current?.focus()}
          >
            {computedPlaceholder}
            <div
              ref={contentEditableRef}
              contentEditable={!disabled}
              className={styles.contentEditable}
              style={{
                outline: 'none',
                wordBreak: 'break-word',
                position: 'relative',
                zIndex: 1,
                padding: inputPadding,
                minHeight: `calc(${inputFontSize} * ${theme.lineHeights.md} + 2 * ${inputPadding})`,
                lineHeight: theme.lineHeights.md,
                fontSize: inputFontSize,
                whiteSpace: 'pre-wrap',
                cursor: 'inherit',
              }}
              onInput={handleInput}
              onKeyDown={handleKeyDown}
              onCompositionStart={handleCompositionStart}
              onCompositionEnd={handleCompositionEnd}
              onBlur={checkPlaceholder}
              onFocus={() => setShowPlaceholder(false)}
              role="textbox"
              aria-multiline="true"
              aria-placeholder={placeholder}
              aria-invalid={!!error}
              aria-describedby={props['aria-describedby']}
            />
          </Box>
        </Popover.Target>
        <Popover.Dropdown ref={popoverRef} p="xs" className={styles.popoverDropdown}>
          {suggestions.length > 0 ? (
            suggestions.map((emote, index) => (
              <Box
                key={emote.key}
                className={styles.suggestionItem}
                data-selected={index === selectedSuggestionIndex || undefined}
                onClick={() => insertEmote(emote)}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  padding: 'var(--mantine-spacing-xs)',
                  cursor: 'pointer',
                  borderRadius: 'var(--mantine-radius-sm)',
                  backgroundColor: index === selectedSuggestionIndex ? theme.colors.gray[7] : 'transparent',
                  color: index === selectedSuggestionIndex ? 'white' : 'inherit',
                  '&:hover': {
                    backgroundColor: theme.colors.gray[1],
                  },
                }}
              >
                <Image src={emote.src} alt="" style={{ width: EMOTE_IMG_SIZE, height: EMOTE_IMG_SIZE }} mr="xs" />
                <Text size="sm" component="span" style={{ flexGrow: 1 }}>
                  {emote.key}
                </Text>
                {index === selectedSuggestionIndex && (
                  <Text size="xs" c="dimmed" ml="xs" component="span">
                    (Enter)
                  </Text>
                )}
              </Box>
            ))
          ) : (
            <Text size="xs" c="dimmed">
              {t('common.noMatches')}
            </Text>
          )}
        </Popover.Dropdown>{' '}
      </Popover>
    </Input.Wrapper>
  )
}
