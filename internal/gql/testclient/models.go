// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package testclient

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/caliecode/la-clipasa/internal/ent/generated/postcategory"
	"github.com/caliecode/la-clipasa/internal/ent/generated/user"
	"github.com/google/uuid"
)

type SearchResult interface {
	IsSearchResult()
}

type APIKey struct {
	ID        uuid.UUID `json:"id"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedAt time.Time `json:"createdAt"`
	APIKey    string    `json:"apiKey"`
	ExpiresOn time.Time `json:"expiresOn"`
	Owner     *User     `json:"owner"`
}

func (APIKey) IsNode() {}

// Return response for createBulkApiKey mutation
type APIKeyBulkCreatePayload struct {
	// Created apiKeys
	APIKeys []*APIKey `json:"apiKeys,omitempty,omitzero"`
}

// A connection to a list of items.
type APIKeyConnection struct {
	// A list of edges.
	Edges []*APIKeyEdge `json:"edges,omitempty,omitzero"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createApiKey mutation
type APIKeyCreatePayload struct {
	// Created apiKey
	APIKey *APIKey `json:"apiKey"`
}

// Return response for deleteApiKey mutation
type APIKeyDeletePayload struct {
	// Deleted apiKey ID
	DeletedID uuid.UUID `json:"deletedID"`
}

// An edge in a connection.
type APIKeyEdge struct {
	// The item at the end of the edge.
	Node *APIKey `json:"node,omitempty,omitzero"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for ApiKey connections
type APIKeyOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order ApiKeys.
	Field APIKeyOrderField `json:"field"`
}

// Return response for updateApiKey mutation
type APIKeyUpdatePayload struct {
	// Updated apiKey
	APIKey *APIKey `json:"apiKey"`
}

// ApiKeyWhereInput is used for filtering ApiKey objects.
// Input was generated by ent.
type APIKeyWhereInput struct {
	Not *APIKeyWhereInput   `json:"not,omitempty"`
	And []*APIKeyWhereInput `json:"and,omitempty"`
	Or  []*APIKeyWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNeq   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGt    *uuid.UUID  `json:"idGT,omitempty"`
	IDGte   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLt    *uuid.UUID  `json:"idLT,omitempty"`
	IDLte   *uuid.UUID  `json:"idLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// api_key field predicates
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNeq          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGt           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGte          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLt           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLte          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`
	// expires_on field predicates
	ExpiresOn      *time.Time   `json:"expiresOn,omitempty"`
	ExpiresOnNeq   *time.Time   `json:"expiresOnNEQ,omitempty"`
	ExpiresOnIn    []*time.Time `json:"expiresOnIn,omitempty"`
	ExpiresOnNotIn []*time.Time `json:"expiresOnNotIn,omitempty"`
	ExpiresOnGt    *time.Time   `json:"expiresOnGT,omitempty"`
	ExpiresOnGte   *time.Time   `json:"expiresOnGTE,omitempty"`
	ExpiresOnLt    *time.Time   `json:"expiresOnLT,omitempty"`
	ExpiresOnLte   *time.Time   `json:"expiresOnLTE,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type Comment struct {
	ID        uuid.UUID  `json:"id"`
	UpdatedAt time.Time  `json:"updatedAt"`
	CreatedAt time.Time  `json:"createdAt"`
	DeletedAt *time.Time `json:"deletedAt,omitempty,omitzero"`
	DeletedBy *string    `json:"deletedBy,omitempty,omitzero"`
	Content   string     `json:"content"`
	Owner     *User      `json:"owner"`
	Post      *Post      `json:"post,omitempty,omitzero"`
}

func (Comment) IsNode() {}

// Return response for createBulkComment mutation
type CommentBulkCreatePayload struct {
	// Created comments
	Comments []*Comment `json:"comments,omitempty,omitzero"`
}

// A connection to a list of items.
type CommentConnection struct {
	// A list of edges.
	Edges []*CommentEdge `json:"edges,omitempty,omitzero"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createComment mutation
type CommentCreatePayload struct {
	// Created comment
	Comment *Comment `json:"comment"`
}

// Return response for deleteComment mutation
type CommentDeletePayload struct {
	// Deleted comment ID
	DeletedID uuid.UUID `json:"deletedID"`
}

// An edge in a connection.
type CommentEdge struct {
	// The item at the end of the edge.
	Node *Comment `json:"node,omitempty,omitzero"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for Comment connections
type CommentOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Comments.
	Field CommentOrderField `json:"field"`
}

// Return response for updateComment mutation
type CommentUpdatePayload struct {
	// Updated comment
	Comment *Comment `json:"comment"`
}

// CommentWhereInput is used for filtering Comment objects.
// Input was generated by ent.
type CommentWhereInput struct {
	Not *CommentWhereInput   `json:"not,omitempty"`
	And []*CommentWhereInput `json:"and,omitempty"`
	Or  []*CommentWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNeq   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGt    *uuid.UUID  `json:"idGT,omitempty"`
	IDGte   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLt    *uuid.UUID  `json:"idLT,omitempty"`
	IDLte   *uuid.UUID  `json:"idLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// content field predicates
	Content             *string  `json:"content,omitempty"`
	ContentNeq          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGt           *string  `json:"contentGT,omitempty"`
	ContentGte          *string  `json:"contentGTE,omitempty"`
	ContentLt           *string  `json:"contentLT,omitempty"`
	ContentLte          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
	// post edge predicates
	HasPost     *bool             `json:"hasPost,omitempty"`
	HasPostWith []*PostWhereInput `json:"hasPostWith,omitempty"`
	// Include soft-deleted records
	IncludeDeleted *bool `json:"includeDeleted,omitempty"`
	// Include only soft-deleted records
	IncludeDeletedOnly *bool `json:"includeDeletedOnly,omitempty"`
}

// CreateApiKeyInput is used for create ApiKey object.
// Input was generated by ent.
type CreateAPIKeyInput struct {
	ExpiresOn time.Time `json:"expiresOn"`
}

// CreateCommentInput is used for create Comment object.
// Input was generated by ent.
type CreateCommentInput struct {
	Content string     `json:"content"`
	OwnerID uuid.UUID  `json:"ownerID"`
	PostID  *uuid.UUID `json:"postID,omitempty"`
}

// CreatePostCategoryInput is used for create PostCategory object.
// Input was generated by ent.
type CreatePostCategoryInput struct {
	Category postcategory.Category `json:"category"`
	PostID   *uuid.UUID            `json:"postID,omitempty"`
}

// CreatePostInput is used for create Post object.
// Input was generated by ent.
type CreatePostInput struct {
	Pinned            *bool       `json:"pinned,omitempty"`
	Title             string      `json:"title"`
	Content           *string     `json:"content,omitempty"`
	Link              string      `json:"link"`
	ModerationComment *string     `json:"moderationComment,omitempty"`
	IsModerated       *bool       `json:"isModerated,omitempty"`
	OwnerID           uuid.UUID   `json:"ownerID"`
	CommentIDs        []uuid.UUID `json:"commentIDs,omitempty"`
	SavedByIDs        []uuid.UUID `json:"savedByIDs,omitempty"`
	LikedByIDs        []uuid.UUID `json:"likedByIDs,omitempty"`
	CategoryIDs       []uuid.UUID `json:"categoryIDs,omitempty"`
}

type CreatePostWithCategoriesInput struct {
	Base       *CreatePostInput        `json:"base"`
	Categories []postcategory.Category `json:"categories,omitempty"`
	Video      *graphql.Upload         `json:"video,omitempty"`
}

// CreateRefreshTokenInput is used for create RefreshToken object.
// Input was generated by ent.
type CreateRefreshTokenInput struct {
	ExpiresAt time.Time `json:"expiresAt"`
	Revoked   *bool     `json:"revoked,omitempty"`
	IPAddress *string   `json:"ipAddress,omitempty"`
	UserAgent *string   `json:"userAgent,omitempty"`
	OwnerID   uuid.UUID `json:"ownerID"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	DisplayName string `json:"displayName"`
	// the alias of the user is shown alongside the display name
	Alias        *string            `json:"alias,omitempty"`
	ProfileImage *string            `json:"profileImage,omitempty"`
	AuthProvider *user.AuthProvider `json:"authProvider,omitempty"`
	// the role of the user
	Role *user.Role `json:"role,omitempty"`
	// the time the user was last seen
	LastSeenAt *time.Time `json:"lastSeenAt,omitempty"`
	// cursor for last post seen
	LastPostSeenCursor *string     `json:"lastPostSeenCursor,omitempty"`
	Awards             []string    `json:"awards,omitempty"`
	SavedPostIDs       []uuid.UUID `json:"savedPostIDs,omitempty"`
	LikedPostIDs       []uuid.UUID `json:"likedPostIDs,omitempty"`
	PublishedPostIDs   []uuid.UUID `json:"publishedPostIDs,omitempty"`
	CommentIDs         []uuid.UUID `json:"commentIDs,omitempty"`
	APIKeyIDs          []uuid.UUID `json:"apiKeyIDs,omitempty"`
}

type DiscordVideoMetadata struct {
	ID         *string    `json:"id,omitempty,omitzero"`
	Expiration *time.Time `json:"expiration,omitempty,omitzero"`
}

type Mutation struct {
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty,omitzero"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty,omitzero"`
}

type Post struct {
	ID                uuid.UUID          `json:"id"`
	UpdatedAt         time.Time          `json:"updatedAt"`
	CreatedAt         time.Time          `json:"createdAt"`
	DeletedAt         *time.Time         `json:"deletedAt,omitempty,omitzero"`
	DeletedBy         *string            `json:"deletedBy,omitempty,omitzero"`
	Pinned            bool               `json:"pinned"`
	Title             string             `json:"title"`
	Content           *string            `json:"content,omitempty,omitzero"`
	Link              string             `json:"link"`
	ModerationComment *string            `json:"moderationComment,omitempty,omitzero"`
	IsModerated       bool               `json:"isModerated"`
	ModeratedAt       *time.Time         `json:"moderatedAt,omitempty,omitzero"`
	EntityVector      *string            `json:"entityVector,omitempty,omitzero"`
	Metadata          *PostMetadata      `json:"metadata,omitempty,omitzero"`
	Owner             *User              `json:"owner"`
	Comments          *CommentConnection `json:"comments"`
	SavedBy           []*User            `json:"savedBy,omitempty,omitzero"`
	LikedBy           *UserConnection    `json:"likedBy"`
	Categories        []*PostCategory    `json:"categories,omitempty,omitzero"`
	ToHTML            string             `json:"toHTML"`
	NodeID            string             `json:"nodeId"`
}

func (Post) IsNode() {}

// Return response for createBulkPost mutation
type PostBulkCreatePayload struct {
	// Created posts
	Posts []*Post `json:"posts,omitempty,omitzero"`
}

type PostCategory struct {
	ID        uuid.UUID             `json:"id"`
	UpdatedAt time.Time             `json:"updatedAt"`
	CreatedAt time.Time             `json:"createdAt"`
	Category  postcategory.Category `json:"category"`
	Post      *Post                 `json:"post,omitempty,omitzero"`
}

func (PostCategory) IsNode() {}

// Return response for createBulkPostCategory mutation
type PostCategoryBulkCreatePayload struct {
	// Created postCategorys
	PostCategories []*PostCategory `json:"postCategories,omitempty,omitzero"`
}

// A connection to a list of items.
type PostCategoryConnection struct {
	// A list of edges.
	Edges []*PostCategoryEdge `json:"edges,omitempty,omitzero"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPostCategory mutation
type PostCategoryCreatePayload struct {
	// Created postCategory
	PostCategory *PostCategory `json:"postCategory"`
}

// Return response for deletePostCategory mutation
type PostCategoryDeletePayload struct {
	// Deleted postCategory ID
	DeletedID uuid.UUID `json:"deletedID"`
}

// An edge in a connection.
type PostCategoryEdge struct {
	// The item at the end of the edge.
	Node *PostCategory `json:"node,omitempty,omitzero"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for PostCategory connections
type PostCategoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order PostCategories.
	Field PostCategoryOrderField `json:"field"`
}

// Return response for updatePostCategory mutation
type PostCategoryUpdatePayload struct {
	// Updated postCategory
	PostCategory *PostCategory `json:"postCategory"`
}

// PostCategoryWhereInput is used for filtering PostCategory objects.
// Input was generated by ent.
type PostCategoryWhereInput struct {
	Not *PostCategoryWhereInput   `json:"not,omitempty"`
	And []*PostCategoryWhereInput `json:"and,omitempty"`
	Or  []*PostCategoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNeq   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGt    *uuid.UUID  `json:"idGT,omitempty"`
	IDGte   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLt    *uuid.UUID  `json:"idLT,omitempty"`
	IDLte   *uuid.UUID  `json:"idLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// category field predicates
	Category      *postcategory.Category  `json:"category,omitempty"`
	CategoryNeq   *postcategory.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []postcategory.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []postcategory.Category `json:"categoryNotIn,omitempty"`
	// post edge predicates
	HasPost     *bool             `json:"hasPost,omitempty"`
	HasPostWith []*PostWhereInput `json:"hasPostWith,omitempty"`
}

// A connection to a list of items.
type PostConnection struct {
	// A list of edges.
	Edges []*PostEdge `json:"edges,omitempty,omitzero"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPost mutation
type PostCreatePayload struct {
	// Created post
	Post *Post `json:"post"`
}

// Return response for deletePost mutation
type PostDeletePayload struct {
	// Deleted post ID
	DeletedID uuid.UUID `json:"deletedID"`
}

// An edge in a connection.
type PostEdge struct {
	// The item at the end of the edge.
	Node *Post `json:"node,omitempty,omitzero"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type PostMetadata struct {
	// Version is the version of the Post metadata.
	Version int64 `json:"version"`
	// Service represents the provider of the Post link.
	Service PostService           `json:"service"`
	Discord *DiscordVideoMetadata `json:"discord,omitempty,omitzero"`
}

// Ordering options for Post connections
type PostOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Posts.
	Field PostOrderField `json:"field"`
}

// Return response for updatePost mutation
type PostUpdatePayload struct {
	// Updated post
	Post *Post `json:"post"`
}

// PostWhereInput is used for filtering Post objects.
// Input was generated by ent.
type PostWhereInput struct {
	Not *PostWhereInput   `json:"not,omitempty"`
	And []*PostWhereInput `json:"and,omitempty"`
	Or  []*PostWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNeq   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGt    *uuid.UUID  `json:"idGT,omitempty"`
	IDGte   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLt    *uuid.UUID  `json:"idLT,omitempty"`
	IDLte   *uuid.UUID  `json:"idLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// pinned field predicates
	Pinned    *bool `json:"pinned,omitempty"`
	PinnedNeq *bool `json:"pinnedNEQ,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// content field predicates
	Content             *string  `json:"content,omitempty"`
	ContentNeq          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGt           *string  `json:"contentGT,omitempty"`
	ContentGte          *string  `json:"contentGTE,omitempty"`
	ContentLt           *string  `json:"contentLT,omitempty"`
	ContentLte          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        *bool    `json:"contentIsNil,omitempty"`
	ContentNotNil       *bool    `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`
	// link field predicates
	Link             *string  `json:"link,omitempty"`
	LinkNeq          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGt           *string  `json:"linkGT,omitempty"`
	LinkGte          *string  `json:"linkGTE,omitempty"`
	LinkLt           *string  `json:"linkLT,omitempty"`
	LinkLte          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`
	// moderation_comment field predicates
	ModerationComment             *string  `json:"moderationComment,omitempty"`
	ModerationCommentNeq          *string  `json:"moderationCommentNEQ,omitempty"`
	ModerationCommentIn           []string `json:"moderationCommentIn,omitempty"`
	ModerationCommentNotIn        []string `json:"moderationCommentNotIn,omitempty"`
	ModerationCommentGt           *string  `json:"moderationCommentGT,omitempty"`
	ModerationCommentGte          *string  `json:"moderationCommentGTE,omitempty"`
	ModerationCommentLt           *string  `json:"moderationCommentLT,omitempty"`
	ModerationCommentLte          *string  `json:"moderationCommentLTE,omitempty"`
	ModerationCommentContains     *string  `json:"moderationCommentContains,omitempty"`
	ModerationCommentHasPrefix    *string  `json:"moderationCommentHasPrefix,omitempty"`
	ModerationCommentHasSuffix    *string  `json:"moderationCommentHasSuffix,omitempty"`
	ModerationCommentIsNil        *bool    `json:"moderationCommentIsNil,omitempty"`
	ModerationCommentNotNil       *bool    `json:"moderationCommentNotNil,omitempty"`
	ModerationCommentEqualFold    *string  `json:"moderationCommentEqualFold,omitempty"`
	ModerationCommentContainsFold *string  `json:"moderationCommentContainsFold,omitempty"`
	// is_moderated field predicates
	IsModerated    *bool `json:"isModerated,omitempty"`
	IsModeratedNeq *bool `json:"isModeratedNEQ,omitempty"`
	// moderated_at field predicates
	ModeratedAt       *time.Time   `json:"moderatedAt,omitempty"`
	ModeratedAtNeq    *time.Time   `json:"moderatedAtNEQ,omitempty"`
	ModeratedAtIn     []*time.Time `json:"moderatedAtIn,omitempty"`
	ModeratedAtNotIn  []*time.Time `json:"moderatedAtNotIn,omitempty"`
	ModeratedAtGt     *time.Time   `json:"moderatedAtGT,omitempty"`
	ModeratedAtGte    *time.Time   `json:"moderatedAtGTE,omitempty"`
	ModeratedAtLt     *time.Time   `json:"moderatedAtLT,omitempty"`
	ModeratedAtLte    *time.Time   `json:"moderatedAtLTE,omitempty"`
	ModeratedAtIsNil  *bool        `json:"moderatedAtIsNil,omitempty"`
	ModeratedAtNotNil *bool        `json:"moderatedAtNotNil,omitempty"`
	// entity_vector field predicates
	EntityVector             *string  `json:"entityVector,omitempty"`
	EntityVectorNeq          *string  `json:"entityVectorNEQ,omitempty"`
	EntityVectorIn           []string `json:"entityVectorIn,omitempty"`
	EntityVectorNotIn        []string `json:"entityVectorNotIn,omitempty"`
	EntityVectorGt           *string  `json:"entityVectorGT,omitempty"`
	EntityVectorGte          *string  `json:"entityVectorGTE,omitempty"`
	EntityVectorLt           *string  `json:"entityVectorLT,omitempty"`
	EntityVectorLte          *string  `json:"entityVectorLTE,omitempty"`
	EntityVectorContains     *string  `json:"entityVectorContains,omitempty"`
	EntityVectorHasPrefix    *string  `json:"entityVectorHasPrefix,omitempty"`
	EntityVectorHasSuffix    *string  `json:"entityVectorHasSuffix,omitempty"`
	EntityVectorIsNil        *bool    `json:"entityVectorIsNil,omitempty"`
	EntityVectorNotNil       *bool    `json:"entityVectorNotNil,omitempty"`
	EntityVectorEqualFold    *string  `json:"entityVectorEqualFold,omitempty"`
	EntityVectorContainsFold *string  `json:"entityVectorContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
	// comments edge predicates
	HasComments     *bool                `json:"hasComments,omitempty"`
	HasCommentsWith []*CommentWhereInput `json:"hasCommentsWith,omitempty"`
	// saved_by edge predicates
	HasSavedBy     *bool             `json:"hasSavedBy,omitempty"`
	HasSavedByWith []*UserWhereInput `json:"hasSavedByWith,omitempty"`
	// liked_by edge predicates
	HasLikedBy     *bool             `json:"hasLikedBy,omitempty"`
	HasLikedByWith []*UserWhereInput `json:"hasLikedByWith,omitempty"`
	// categories edge predicates
	HasCategories     *bool                     `json:"hasCategories,omitempty"`
	HasCategoriesWith []*PostCategoryWhereInput `json:"hasCategoriesWith,omitempty"`
	// Include soft-deleted records
	IncludeDeleted *bool `json:"includeDeleted,omitempty"`
	// Include only soft-deleted records
	IncludeDeletedOnly *bool `json:"includeDeletedOnly,omitempty"`
}

type Query struct {
}

type RefreshToken struct {
	ID        uuid.UUID `json:"id"`
	UpdatedAt time.Time `json:"updatedAt"`
	CreatedAt time.Time `json:"createdAt"`
	ExpiresAt time.Time `json:"expiresAt"`
	Revoked   bool      `json:"revoked"`
	IPAddress *string   `json:"ipAddress,omitempty,omitzero"`
	UserAgent *string   `json:"userAgent,omitempty,omitzero"`
	Owner     *User     `json:"owner"`
}

func (RefreshToken) IsNode() {}

// Return response for createBulkRefreshToken mutation
type RefreshTokenBulkCreatePayload struct {
	// Created refreshTokens
	RefreshTokens []*RefreshToken `json:"refreshTokens,omitempty,omitzero"`
}

// A connection to a list of items.
type RefreshTokenConnection struct {
	// A list of edges.
	Edges []*RefreshTokenEdge `json:"edges,omitempty,omitzero"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createRefreshToken mutation
type RefreshTokenCreatePayload struct {
	// Created refreshToken
	RefreshToken *RefreshToken `json:"refreshToken"`
}

// Return response for deleteRefreshToken mutation
type RefreshTokenDeletePayload struct {
	// Deleted refreshToken ID
	DeletedID uuid.UUID `json:"deletedID"`
}

// An edge in a connection.
type RefreshTokenEdge struct {
	// The item at the end of the edge.
	Node *RefreshToken `json:"node,omitempty,omitzero"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for RefreshToken connections
type RefreshTokenOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order RefreshTokens.
	Field RefreshTokenOrderField `json:"field"`
}

// Return response for updateRefreshToken mutation
type RefreshTokenUpdatePayload struct {
	// Updated refreshToken
	RefreshToken *RefreshToken `json:"refreshToken"`
}

// RefreshTokenWhereInput is used for filtering RefreshToken objects.
// Input was generated by ent.
type RefreshTokenWhereInput struct {
	Not *RefreshTokenWhereInput   `json:"not,omitempty"`
	And []*RefreshTokenWhereInput `json:"and,omitempty"`
	Or  []*RefreshTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNeq   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGt    *uuid.UUID  `json:"idGT,omitempty"`
	IDGte   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLt    *uuid.UUID  `json:"idLT,omitempty"`
	IDLte   *uuid.UUID  `json:"idLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// expires_at field predicates
	ExpiresAt      *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq   *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn    []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt    *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte   *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt    *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte   *time.Time   `json:"expiresAtLTE,omitempty"`
	// revoked field predicates
	Revoked    *bool `json:"revoked,omitempty"`
	RevokedNeq *bool `json:"revokedNEQ,omitempty"`
	// ip_address field predicates
	IPAddress             *string  `json:"ipAddress,omitempty"`
	IPAddressNeq          *string  `json:"ipAddressNEQ,omitempty"`
	IPAddressIn           []string `json:"ipAddressIn,omitempty"`
	IPAddressNotIn        []string `json:"ipAddressNotIn,omitempty"`
	IPAddressGt           *string  `json:"ipAddressGT,omitempty"`
	IPAddressGte          *string  `json:"ipAddressGTE,omitempty"`
	IPAddressLt           *string  `json:"ipAddressLT,omitempty"`
	IPAddressLte          *string  `json:"ipAddressLTE,omitempty"`
	IPAddressContains     *string  `json:"ipAddressContains,omitempty"`
	IPAddressHasPrefix    *string  `json:"ipAddressHasPrefix,omitempty"`
	IPAddressHasSuffix    *string  `json:"ipAddressHasSuffix,omitempty"`
	IPAddressIsNil        *bool    `json:"ipAddressIsNil,omitempty"`
	IPAddressNotNil       *bool    `json:"ipAddressNotNil,omitempty"`
	IPAddressEqualFold    *string  `json:"ipAddressEqualFold,omitempty"`
	IPAddressContainsFold *string  `json:"ipAddressContainsFold,omitempty"`
	// user_agent field predicates
	UserAgent             *string  `json:"userAgent,omitempty"`
	UserAgentNeq          *string  `json:"userAgentNEQ,omitempty"`
	UserAgentIn           []string `json:"userAgentIn,omitempty"`
	UserAgentNotIn        []string `json:"userAgentNotIn,omitempty"`
	UserAgentGt           *string  `json:"userAgentGT,omitempty"`
	UserAgentGte          *string  `json:"userAgentGTE,omitempty"`
	UserAgentLt           *string  `json:"userAgentLT,omitempty"`
	UserAgentLte          *string  `json:"userAgentLTE,omitempty"`
	UserAgentContains     *string  `json:"userAgentContains,omitempty"`
	UserAgentHasPrefix    *string  `json:"userAgentHasPrefix,omitempty"`
	UserAgentHasSuffix    *string  `json:"userAgentHasSuffix,omitempty"`
	UserAgentIsNil        *bool    `json:"userAgentIsNil,omitempty"`
	UserAgentNotNil       *bool    `json:"userAgentNotNil,omitempty"`
	UserAgentEqualFold    *string  `json:"userAgentEqualFold,omitempty"`
	UserAgentContainsFold *string  `json:"userAgentContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type SearchResultConnection struct {
	// Information to aid in pagination.
	Page *PageInfo `json:"page"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
	// A list of nodes with results.
	Nodes []SearchResult `json:"nodes"`
}

// UpdateApiKeyInput is used for update ApiKey object.
// Input was generated by ent.
type UpdateAPIKeyInput struct {
	ExpiresOn *time.Time `json:"expiresOn,omitempty"`
}

// UpdateCommentInput is used for update Comment object.
// Input was generated by ent.
type UpdateCommentInput struct {
	Content   *string    `json:"content,omitempty"`
	OwnerID   *uuid.UUID `json:"ownerID,omitempty"`
	PostID    *uuid.UUID `json:"postID,omitempty"`
	ClearPost *bool      `json:"clearPost,omitempty"`
}

// UpdatePostCategoryInput is used for update PostCategory object.
// Input was generated by ent.
type UpdatePostCategoryInput struct {
	Category  *postcategory.Category `json:"category,omitempty"`
	PostID    *uuid.UUID             `json:"postID,omitempty"`
	ClearPost *bool                  `json:"clearPost,omitempty"`
}

// UpdatePostInput is used for update Post object.
// Input was generated by ent.
type UpdatePostInput struct {
	Pinned                 *bool       `json:"pinned,omitempty"`
	Title                  *string     `json:"title,omitempty"`
	Content                *string     `json:"content,omitempty"`
	ClearContent           *bool       `json:"clearContent,omitempty"`
	Link                   *string     `json:"link,omitempty"`
	ModerationComment      *string     `json:"moderationComment,omitempty"`
	ClearModerationComment *bool       `json:"clearModerationComment,omitempty"`
	IsModerated            *bool       `json:"isModerated,omitempty"`
	AddCommentIDs          []uuid.UUID `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs       []uuid.UUID `json:"removeCommentIDs,omitempty"`
	ClearComments          *bool       `json:"clearComments,omitempty"`
	AddSavedByIDs          []uuid.UUID `json:"addSavedByIDs,omitempty"`
	RemoveSavedByIDs       []uuid.UUID `json:"removeSavedByIDs,omitempty"`
	ClearSavedBy           *bool       `json:"clearSavedBy,omitempty"`
	AddLikedByIDs          []uuid.UUID `json:"addLikedByIDs,omitempty"`
	RemoveLikedByIDs       []uuid.UUID `json:"removeLikedByIDs,omitempty"`
	ClearLikedBy           *bool       `json:"clearLikedBy,omitempty"`
	AddCategoryIDs         []uuid.UUID `json:"addCategoryIDs,omitempty"`
	RemoveCategoryIDs      []uuid.UUID `json:"removeCategoryIDs,omitempty"`
	ClearCategories        *bool       `json:"clearCategories,omitempty"`
}

type UpdatePostWithCategoriesInput struct {
	Base       *UpdatePostInput        `json:"base"`
	Categories []postcategory.Category `json:"categories,omitempty"`
	Video      *graphql.Upload         `json:"video,omitempty"`
}

// UpdateRefreshTokenInput is used for update RefreshToken object.
// Input was generated by ent.
type UpdateRefreshTokenInput struct {
	ExpiresAt      *time.Time `json:"expiresAt,omitempty"`
	Revoked        *bool      `json:"revoked,omitempty"`
	IPAddress      *string    `json:"ipAddress,omitempty"`
	ClearIPAddress *bool      `json:"clearIPAddress,omitempty"`
	UserAgent      *string    `json:"userAgent,omitempty"`
	ClearUserAgent *bool      `json:"clearUserAgent,omitempty"`
	OwnerID        *uuid.UUID `json:"ownerID,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	DisplayName *string `json:"displayName,omitempty"`
	// the alias of the user is shown alongside the display name
	Alias             *string            `json:"alias,omitempty"`
	ClearAlias        *bool              `json:"clearAlias,omitempty"`
	ProfileImage      *string            `json:"profileImage,omitempty"`
	ClearProfileImage *bool              `json:"clearProfileImage,omitempty"`
	AuthProvider      *user.AuthProvider `json:"authProvider,omitempty"`
	// the role of the user
	Role *user.Role `json:"role,omitempty"`
	// the time the user was last seen
	LastSeenAt      *time.Time `json:"lastSeenAt,omitempty"`
	ClearLastSeenAt *bool      `json:"clearLastSeenAt,omitempty"`
	// cursor for last post seen
	LastPostSeenCursor      *string     `json:"lastPostSeenCursor,omitempty"`
	ClearLastPostSeenCursor *bool       `json:"clearLastPostSeenCursor,omitempty"`
	Awards                  []string    `json:"awards,omitempty"`
	AppendAwards            []string    `json:"appendAwards,omitempty"`
	ClearAwards             *bool       `json:"clearAwards,omitempty"`
	AddSavedPostIDs         []uuid.UUID `json:"addSavedPostIDs,omitempty"`
	RemoveSavedPostIDs      []uuid.UUID `json:"removeSavedPostIDs,omitempty"`
	ClearSavedPosts         *bool       `json:"clearSavedPosts,omitempty"`
	AddLikedPostIDs         []uuid.UUID `json:"addLikedPostIDs,omitempty"`
	RemoveLikedPostIDs      []uuid.UUID `json:"removeLikedPostIDs,omitempty"`
	ClearLikedPosts         *bool       `json:"clearLikedPosts,omitempty"`
	AddPublishedPostIDs     []uuid.UUID `json:"addPublishedPostIDs,omitempty"`
	RemovePublishedPostIDs  []uuid.UUID `json:"removePublishedPostIDs,omitempty"`
	ClearPublishedPosts     *bool       `json:"clearPublishedPosts,omitempty"`
	AddCommentIDs           []uuid.UUID `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs        []uuid.UUID `json:"removeCommentIDs,omitempty"`
	ClearComments           *bool       `json:"clearComments,omitempty"`
	AddAPIKeyIDs            []uuid.UUID `json:"addAPIKeyIDs,omitempty"`
	RemoveAPIKeyIDs         []uuid.UUID `json:"removeAPIKeyIDs,omitempty"`
	ClearAPIKeys            *bool       `json:"clearAPIKeys,omitempty"`
}

type User struct {
	ID          uuid.UUID  `json:"id"`
	UpdatedAt   time.Time  `json:"updatedAt"`
	CreatedAt   time.Time  `json:"createdAt"`
	DeletedAt   *time.Time `json:"deletedAt,omitempty,omitzero"`
	DeletedBy   *string    `json:"deletedBy,omitempty,omitzero"`
	DisplayName string     `json:"displayName"`
	// the alias of the user is shown alongside the display name
	Alias        *string           `json:"alias,omitempty,omitzero"`
	ProfileImage *string           `json:"profileImage,omitempty,omitzero"`
	AuthProvider user.AuthProvider `json:"authProvider"`
	// the role of the user
	Role user.Role `json:"role"`
	// the time the user was last seen
	LastSeenAt *time.Time `json:"lastSeenAt,omitempty,omitzero"`
	// cursor for last post seen
	LastPostSeenCursor *string         `json:"lastPostSeenCursor,omitempty,omitzero"`
	Awards             []string        `json:"awards,omitempty,omitzero"`
	SavedPosts         []*Post         `json:"savedPosts,omitempty,omitzero"`
	LikedPosts         []*Post         `json:"likedPosts,omitempty,omitzero"`
	PublishedPosts     []*Post         `json:"publishedPosts,omitempty,omitzero"`
	Comments           []*Comment      `json:"comments,omitempty,omitzero"`
	APIKeys            []*APIKey       `json:"apiKeys,omitempty,omitzero"`
	TwitchInfo         *UserTwitchInfo `json:"twitchInfo,omitempty,omitzero"`
}

func (User) IsNode() {}

// Return response for createBulkUser mutation
type UserBulkCreatePayload struct {
	// Created users
	Users []*User `json:"users,omitempty,omitzero"`
}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty,omitzero"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User *User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID uuid.UUID `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty,omitzero"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

type UserSearchResult struct {
	Users []*User `json:"users,omitempty,omitzero"`
}

func (UserSearchResult) IsSearchResult() {}

type UserTwitchInfo struct {
	IsSubscriber  *bool `json:"isSubscriber,omitempty,omitzero"`
	IsFollower    *bool `json:"isFollower,omitempty,omitzero"`
	IsBroadcaster *bool `json:"isBroadcaster,omitempty,omitzero"`
	IsBanned      *bool `json:"isBanned,omitempty,omitzero"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User *User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNeq   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGt    *uuid.UUID  `json:"idGT,omitempty"`
	IDGte   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLt    *uuid.UUID  `json:"idLT,omitempty"`
	IDLte   *uuid.UUID  `json:"idLTE,omitempty"`
	// updated_at field predicates
	UpdatedAt      *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq   *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt    *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte   *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt    *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte   *time.Time   `json:"updatedAtLTE,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// alias field predicates
	Alias             *string  `json:"alias,omitempty"`
	AliasNeq          *string  `json:"aliasNEQ,omitempty"`
	AliasIn           []string `json:"aliasIn,omitempty"`
	AliasNotIn        []string `json:"aliasNotIn,omitempty"`
	AliasGt           *string  `json:"aliasGT,omitempty"`
	AliasGte          *string  `json:"aliasGTE,omitempty"`
	AliasLt           *string  `json:"aliasLT,omitempty"`
	AliasLte          *string  `json:"aliasLTE,omitempty"`
	AliasContains     *string  `json:"aliasContains,omitempty"`
	AliasHasPrefix    *string  `json:"aliasHasPrefix,omitempty"`
	AliasHasSuffix    *string  `json:"aliasHasSuffix,omitempty"`
	AliasIsNil        *bool    `json:"aliasIsNil,omitempty"`
	AliasNotNil       *bool    `json:"aliasNotNil,omitempty"`
	AliasEqualFold    *string  `json:"aliasEqualFold,omitempty"`
	AliasContainsFold *string  `json:"aliasContainsFold,omitempty"`
	// profile_image field predicates
	ProfileImage             *string  `json:"profileImage,omitempty"`
	ProfileImageNeq          *string  `json:"profileImageNEQ,omitempty"`
	ProfileImageIn           []string `json:"profileImageIn,omitempty"`
	ProfileImageNotIn        []string `json:"profileImageNotIn,omitempty"`
	ProfileImageGt           *string  `json:"profileImageGT,omitempty"`
	ProfileImageGte          *string  `json:"profileImageGTE,omitempty"`
	ProfileImageLt           *string  `json:"profileImageLT,omitempty"`
	ProfileImageLte          *string  `json:"profileImageLTE,omitempty"`
	ProfileImageContains     *string  `json:"profileImageContains,omitempty"`
	ProfileImageHasPrefix    *string  `json:"profileImageHasPrefix,omitempty"`
	ProfileImageHasSuffix    *string  `json:"profileImageHasSuffix,omitempty"`
	ProfileImageIsNil        *bool    `json:"profileImageIsNil,omitempty"`
	ProfileImageNotNil       *bool    `json:"profileImageNotNil,omitempty"`
	ProfileImageEqualFold    *string  `json:"profileImageEqualFold,omitempty"`
	ProfileImageContainsFold *string  `json:"profileImageContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *user.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *user.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []user.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []user.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role      *user.Role  `json:"role,omitempty"`
	RoleNeq   *user.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []user.Role `json:"roleIn,omitempty"`
	RoleNotIn []user.Role `json:"roleNotIn,omitempty"`
	// last_seen_at field predicates
	LastSeenAt       *time.Time   `json:"lastSeenAt,omitempty"`
	LastSeenAtNeq    *time.Time   `json:"lastSeenAtNEQ,omitempty"`
	LastSeenAtIn     []*time.Time `json:"lastSeenAtIn,omitempty"`
	LastSeenAtNotIn  []*time.Time `json:"lastSeenAtNotIn,omitempty"`
	LastSeenAtGt     *time.Time   `json:"lastSeenAtGT,omitempty"`
	LastSeenAtGte    *time.Time   `json:"lastSeenAtGTE,omitempty"`
	LastSeenAtLt     *time.Time   `json:"lastSeenAtLT,omitempty"`
	LastSeenAtLte    *time.Time   `json:"lastSeenAtLTE,omitempty"`
	LastSeenAtIsNil  *bool        `json:"lastSeenAtIsNil,omitempty"`
	LastSeenAtNotNil *bool        `json:"lastSeenAtNotNil,omitempty"`
	// last_post_seen_cursor field predicates
	LastPostSeenCursor             *string  `json:"lastPostSeenCursor,omitempty"`
	LastPostSeenCursorNeq          *string  `json:"lastPostSeenCursorNEQ,omitempty"`
	LastPostSeenCursorIn           []string `json:"lastPostSeenCursorIn,omitempty"`
	LastPostSeenCursorNotIn        []string `json:"lastPostSeenCursorNotIn,omitempty"`
	LastPostSeenCursorGt           *string  `json:"lastPostSeenCursorGT,omitempty"`
	LastPostSeenCursorGte          *string  `json:"lastPostSeenCursorGTE,omitempty"`
	LastPostSeenCursorLt           *string  `json:"lastPostSeenCursorLT,omitempty"`
	LastPostSeenCursorLte          *string  `json:"lastPostSeenCursorLTE,omitempty"`
	LastPostSeenCursorContains     *string  `json:"lastPostSeenCursorContains,omitempty"`
	LastPostSeenCursorHasPrefix    *string  `json:"lastPostSeenCursorHasPrefix,omitempty"`
	LastPostSeenCursorHasSuffix    *string  `json:"lastPostSeenCursorHasSuffix,omitempty"`
	LastPostSeenCursorIsNil        *bool    `json:"lastPostSeenCursorIsNil,omitempty"`
	LastPostSeenCursorNotNil       *bool    `json:"lastPostSeenCursorNotNil,omitempty"`
	LastPostSeenCursorEqualFold    *string  `json:"lastPostSeenCursorEqualFold,omitempty"`
	LastPostSeenCursorContainsFold *string  `json:"lastPostSeenCursorContainsFold,omitempty"`
	// saved_posts edge predicates
	HasSavedPosts     *bool             `json:"hasSavedPosts,omitempty"`
	HasSavedPostsWith []*PostWhereInput `json:"hasSavedPostsWith,omitempty"`
	// liked_posts edge predicates
	HasLikedPosts     *bool             `json:"hasLikedPosts,omitempty"`
	HasLikedPostsWith []*PostWhereInput `json:"hasLikedPostsWith,omitempty"`
	// published_posts edge predicates
	HasPublishedPosts     *bool             `json:"hasPublishedPosts,omitempty"`
	HasPublishedPostsWith []*PostWhereInput `json:"hasPublishedPostsWith,omitempty"`
	// comments edge predicates
	HasComments     *bool                `json:"hasComments,omitempty"`
	HasCommentsWith []*CommentWhereInput `json:"hasCommentsWith,omitempty"`
	// api_keys edge predicates
	HasAPIKeys     *bool               `json:"hasAPIKeys,omitempty"`
	HasAPIKeysWith []*APIKeyWhereInput `json:"hasAPIKeysWith,omitempty"`
	// Include soft-deleted records
	IncludeDeleted *bool `json:"includeDeleted,omitempty"`
	// Include only soft-deleted records
	IncludeDeletedOnly *bool `json:"includeDeletedOnly,omitempty"`
}

// Properties by which ApiKey connections can be ordered.
type APIKeyOrderField string

const (
	APIKeyOrderFieldID        APIKeyOrderField = "ID"
	APIKeyOrderFieldUpdatedAt APIKeyOrderField = "UPDATED_AT"
	APIKeyOrderFieldCreatedAt APIKeyOrderField = "CREATED_AT"
)

var AllAPIKeyOrderField = []APIKeyOrderField{
	APIKeyOrderFieldID,
	APIKeyOrderFieldUpdatedAt,
	APIKeyOrderFieldCreatedAt,
}

func (e APIKeyOrderField) IsValid() bool {
	switch e {
	case APIKeyOrderFieldID, APIKeyOrderFieldUpdatedAt, APIKeyOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e APIKeyOrderField) String() string {
	return string(e)
}

func (e *APIKeyOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = APIKeyOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ApiKeyOrderField", str)
	}
	return nil
}

func (e APIKeyOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *APIKeyOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e APIKeyOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Comment connections can be ordered.
type CommentOrderField string

const (
	CommentOrderFieldID        CommentOrderField = "ID"
	CommentOrderFieldUpdatedAt CommentOrderField = "UPDATED_AT"
	CommentOrderFieldCreatedAt CommentOrderField = "CREATED_AT"
)

var AllCommentOrderField = []CommentOrderField{
	CommentOrderFieldID,
	CommentOrderFieldUpdatedAt,
	CommentOrderFieldCreatedAt,
}

func (e CommentOrderField) IsValid() bool {
	switch e {
	case CommentOrderFieldID, CommentOrderFieldUpdatedAt, CommentOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e CommentOrderField) String() string {
	return string(e)
}

func (e *CommentOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentOrderField", str)
	}
	return nil
}

func (e CommentOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CommentOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CommentOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which PostCategory connections can be ordered.
type PostCategoryOrderField string

const (
	PostCategoryOrderFieldID        PostCategoryOrderField = "ID"
	PostCategoryOrderFieldUpdatedAt PostCategoryOrderField = "UPDATED_AT"
	PostCategoryOrderFieldCreatedAt PostCategoryOrderField = "CREATED_AT"
)

var AllPostCategoryOrderField = []PostCategoryOrderField{
	PostCategoryOrderFieldID,
	PostCategoryOrderFieldUpdatedAt,
	PostCategoryOrderFieldCreatedAt,
}

func (e PostCategoryOrderField) IsValid() bool {
	switch e {
	case PostCategoryOrderFieldID, PostCategoryOrderFieldUpdatedAt, PostCategoryOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e PostCategoryOrderField) String() string {
	return string(e)
}

func (e *PostCategoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostCategoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostCategoryOrderField", str)
	}
	return nil
}

func (e PostCategoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PostCategoryOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PostCategoryOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which Post connections can be ordered.
type PostOrderField string

const (
	PostOrderFieldID            PostOrderField = "ID"
	PostOrderFieldUpdatedAt     PostOrderField = "UPDATED_AT"
	PostOrderFieldCreatedAt     PostOrderField = "CREATED_AT"
	PostOrderFieldModeratedAt   PostOrderField = "MODERATED_AT"
	PostOrderFieldCommentsCount PostOrderField = "COMMENTS_COUNT"
	PostOrderFieldLikedByCount  PostOrderField = "LIKED_BY_COUNT"
)

var AllPostOrderField = []PostOrderField{
	PostOrderFieldID,
	PostOrderFieldUpdatedAt,
	PostOrderFieldCreatedAt,
	PostOrderFieldModeratedAt,
	PostOrderFieldCommentsCount,
	PostOrderFieldLikedByCount,
}

func (e PostOrderField) IsValid() bool {
	switch e {
	case PostOrderFieldID, PostOrderFieldUpdatedAt, PostOrderFieldCreatedAt, PostOrderFieldModeratedAt, PostOrderFieldCommentsCount, PostOrderFieldLikedByCount:
		return true
	}
	return false
}

func (e PostOrderField) String() string {
	return string(e)
}

func (e *PostOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostOrderField", str)
	}
	return nil
}

func (e PostOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PostOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PostOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PostService string

const (
	PostServiceDiscord PostService = "DISCORD"
	PostServiceUnknown PostService = "UNKNOWN"
)

var AllPostService = []PostService{
	PostServiceDiscord,
	PostServiceUnknown,
}

func (e PostService) IsValid() bool {
	switch e {
	case PostServiceDiscord, PostServiceUnknown:
		return true
	}
	return false
}

func (e PostService) String() string {
	return string(e)
}

func (e *PostService) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostService(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostService", str)
	}
	return nil
}

func (e PostService) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PostService) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PostService) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which RefreshToken connections can be ordered.
type RefreshTokenOrderField string

const (
	RefreshTokenOrderFieldUpdatedAt RefreshTokenOrderField = "UPDATED_AT"
	RefreshTokenOrderFieldCreatedAt RefreshTokenOrderField = "CREATED_AT"
)

var AllRefreshTokenOrderField = []RefreshTokenOrderField{
	RefreshTokenOrderFieldUpdatedAt,
	RefreshTokenOrderFieldCreatedAt,
}

func (e RefreshTokenOrderField) IsValid() bool {
	switch e {
	case RefreshTokenOrderFieldUpdatedAt, RefreshTokenOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e RefreshTokenOrderField) String() string {
	return string(e)
}

func (e *RefreshTokenOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RefreshTokenOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RefreshTokenOrderField", str)
	}
	return nil
}

func (e RefreshTokenOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RefreshTokenOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RefreshTokenOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldID        UserOrderField = "ID"
	UserOrderFieldUpdatedAt UserOrderField = "UPDATED_AT"
	UserOrderFieldCreatedAt UserOrderField = "CREATED_AT"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldID,
	UserOrderFieldUpdatedAt,
	UserOrderFieldCreatedAt,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldID, UserOrderFieldUpdatedAt, UserOrderFieldCreatedAt:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserOrderField) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserOrderField) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
