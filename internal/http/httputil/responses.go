package httputil

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"

	"github.com/caliecode/la-clipasa/internal"
	"github.com/caliecode/la-clipasa/internal/utils/pointers"
	"github.com/gin-gonic/gin"
)

// HTTPError represents an error message response.
type HTTPError struct {
	Detail string `json:"detail"`
	Error  string `json:"error"`

	// Loc location in body path, if any
	Loc    *[]string `json:"loc,omitempty"`
	Status int       `json:"status"`
	Title  string    `json:"title"`

	// Type Represents standardized HTTP error types.
	// Notes:
	// - 'Private' marks an error to be hidden in response.
	Type internal.ErrorCode `json:"type"`
}

// HandlerExitError is used to exit handlers early after rendering an error response.
type HandlerExitError struct {
	Err error
}

func (e *HandlerExitError) Error() string {
	return "handler exit requested: " + e.Err.Error()
}

type RenderErrorOptions struct {
	WithoutPanic bool
}

type RenderErrorOption func(*RenderErrorOptions)

// RenderWithoutPanic prevents renderErrorResponse from panicking with a HandlerExitError.
func RenderWithoutPanic() RenderErrorOption {
	return func(o *RenderErrorOptions) {
		o.WithoutPanic = true
	}
}

// RenderError writes an error response from title and error.
// When used inside a StrictHandlers' handler, it panics with a HandlerExitError which
// is recovered immediately by the handler wrapper.
// When used outside a StrictHandlers' handler, WithoutPanic must be used to prevent unrecovered panics.
// title represents an error title which will be shown to end users.
// Inspired by https://www.rfc-editor.org/rfc/rfc7807.
func RenderError(c *gin.Context, title string, err error, opts ...RenderErrorOption) {
	options := RenderErrorOptions{}
	for _, opt := range opts {
		opt(&options)
	}

	if err == nil {
		err = errors.New("unknown error")
	}

	resp := HTTPError{
		Title:  title,
		Error:  err.Error(),
		Type:   internal.ErrorCodeUnknown,
		Status: http.StatusInternalServerError,
	}

	/**
	 *
	 *
	 *

	o  "type" (string) - A URI reference [RFC3986] that identifies the
		 problem type.  This specification encourages that, when
		 dereferenced, it provide human-readable documentation for the
		 problem type (e.g., using HTML [W3C.REC-html5-20141028]).  When
		 this member is not present, its value is assumed to be
		 "about:blank".
		 TODO: simple html page with fragments, generated from mapping
		 ErrCode to go tmpl
		 : /problems#NotFound

	o  "title" (string) - A short, human-readable summary of the problem
		 type.  It SHOULD NOT change from occurrence to occurrence of the
		 problem, except for purposes of localization (e.g., using
		 proactive content negotiation; see [RFC7231], Section 3.4).

	o  "status" (number) - The HTTP status code ([RFC7231], Section 6)
		 generated by the origin server for this occurrence of the problem.

	o  "detail" (string) - A human-readable explanation specific to this
		 occurrence of the problem.
	*/

	var ierr *internal.Error
	if !errors.As(err, &ierr) {
		resp.Title = "internal error"
		resp.Detail = title
	} else {
		resp.Loc = pointers.New(ierr.Loc())
		resp.Type = ierr.Code()
		resp.Detail = ierr.Cause().Error()
		switch ierr.Code() {
		case internal.ErrorCodeNotFound:
			resp.Status = http.StatusNotFound
		case internal.ErrorCodeInvalidArgument:
			resp.Status = http.StatusBadRequest
		case internal.ErrorCodeInvalidRole, internal.ErrorCodeInvalidScope, internal.ErrorCodeInvalidUUID:
			resp.Status = http.StatusBadRequest
		case internal.ErrorCodeAlreadyExists:
			resp.Status = http.StatusConflict
		case internal.ErrorCodeUnauthorized:
			resp.Status = http.StatusForbidden
		case internal.ErrorCodeUnauthenticated:
			resp.Status = http.StatusUnauthorized
		case internal.ErrorCodePrivate:
			if os.Getenv("TESTING") != "" {
				resp = HTTPError{
					Title:  "internal private error",
					Detail: "internal private error. See logs for more details.",
				}
			}

			fallthrough
		case internal.ErrorCodeUnknown:
			fallthrough
		default:
			resp.Status = http.StatusInternalServerError
		}
	}

	renderResponse(c, resp, resp.Status)

	// will trigger handler exit only for convenience in handlers and their utility functions.
	// it then recovers and executes subsequent middlewares.
	if !options.WithoutPanic {
		panic(&HandlerExitError{
			Err: err,
		})
	}
}

func renderResponse(c *gin.Context, res any, status int) {
	c.Header("Content-Type", "application/json")

	content, err := json.Marshal(res)
	if err != nil {
		// TODO Do something with the error
		fmt.Printf("error in renderResponse Marshal: %s\n", err)
		// c.Status(http.StatusInternalServerError)

		return
	}

	c.Status(status)

	if _, err = c.Writer.Write(content); err != nil { //nolint: staticcheck
		// TODO Do something with the error
		fmt.Printf("error in renderResponse Write: %s\n", err)
	}
}

// parseBody attempts to bind the given struct to the request body
// and returns whether the caller should exit early or not.
func parseBody(c *gin.Context, body any) bool {
	if err := c.BindJSON(body); err != nil {
		// openapi validator should have caught a validation error beforehand
		// for routes that have validator mw enabled.
		RenderError(c, "Invalid data", internal.WrapErrorf(err, internal.ErrorCodeInvalidArgument, "invalid data"))

		return true
	}

	return false
}

func rawMessage(data any) json.RawMessage {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return json.RawMessage{}
	}

	return json.RawMessage(jsonData)
}
