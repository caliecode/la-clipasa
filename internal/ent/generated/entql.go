// Code generated by ent, DO NOT EDIT.

package generated

import (
	"github.com/laclipasa/la-clipasa/internal/ent/generated/apikey"
	"github.com/laclipasa/la-clipasa/internal/ent/generated/comment"
	"github.com/laclipasa/la-clipasa/internal/ent/generated/post"
	"github.com/laclipasa/la-clipasa/internal/ent/generated/postcategory"
	"github.com/laclipasa/la-clipasa/internal/ent/generated/predicate"
	"github.com/laclipasa/la-clipasa/internal/ent/generated/user"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 5)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   apikey.Table,
			Columns: apikey.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: apikey.FieldID,
			},
		},
		Type: "ApiKey",
		Fields: map[string]*sqlgraph.FieldSpec{
			apikey.FieldUpdatedAt: {Type: field.TypeTime, Column: apikey.FieldUpdatedAt},
			apikey.FieldCreatedAt: {Type: field.TypeTime, Column: apikey.FieldCreatedAt},
			apikey.FieldOwnerID:   {Type: field.TypeUUID, Column: apikey.FieldOwnerID},
			apikey.FieldAPIKey:    {Type: field.TypeString, Column: apikey.FieldAPIKey},
			apikey.FieldExpiresOn: {Type: field.TypeTime, Column: apikey.FieldExpiresOn},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   comment.Table,
			Columns: comment.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: comment.FieldID,
			},
		},
		Type: "Comment",
		Fields: map[string]*sqlgraph.FieldSpec{
			comment.FieldUpdatedAt: {Type: field.TypeTime, Column: comment.FieldUpdatedAt},
			comment.FieldCreatedAt: {Type: field.TypeTime, Column: comment.FieldCreatedAt},
			comment.FieldDeletedAt: {Type: field.TypeTime, Column: comment.FieldDeletedAt},
			comment.FieldDeletedBy: {Type: field.TypeString, Column: comment.FieldDeletedBy},
			comment.FieldOwnerID:   {Type: field.TypeUUID, Column: comment.FieldOwnerID},
			comment.FieldContent:   {Type: field.TypeString, Column: comment.FieldContent},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   post.Table,
			Columns: post.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: post.FieldID,
			},
		},
		Type: "Post",
		Fields: map[string]*sqlgraph.FieldSpec{
			post.FieldUpdatedAt:         {Type: field.TypeTime, Column: post.FieldUpdatedAt},
			post.FieldCreatedAt:         {Type: field.TypeTime, Column: post.FieldCreatedAt},
			post.FieldDeletedAt:         {Type: field.TypeTime, Column: post.FieldDeletedAt},
			post.FieldDeletedBy:         {Type: field.TypeString, Column: post.FieldDeletedBy},
			post.FieldOwnerID:           {Type: field.TypeUUID, Column: post.FieldOwnerID},
			post.FieldPinned:            {Type: field.TypeBool, Column: post.FieldPinned},
			post.FieldTitle:             {Type: field.TypeString, Column: post.FieldTitle},
			post.FieldContent:           {Type: field.TypeString, Column: post.FieldContent},
			post.FieldLink:              {Type: field.TypeString, Column: post.FieldLink},
			post.FieldModerationComment: {Type: field.TypeString, Column: post.FieldModerationComment},
			post.FieldIsModerated:       {Type: field.TypeBool, Column: post.FieldIsModerated},
			post.FieldEntityVector:      {Type: field.TypeString, Column: post.FieldEntityVector},
		},
	}
	graph.Nodes[3] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   postcategory.Table,
			Columns: postcategory.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: postcategory.FieldID,
			},
		},
		Type: "PostCategory",
		Fields: map[string]*sqlgraph.FieldSpec{
			postcategory.FieldUpdatedAt: {Type: field.TypeTime, Column: postcategory.FieldUpdatedAt},
			postcategory.FieldCreatedAt: {Type: field.TypeTime, Column: postcategory.FieldCreatedAt},
			postcategory.FieldCategory:  {Type: field.TypeEnum, Column: postcategory.FieldCategory},
		},
	}
	graph.Nodes[4] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: user.FieldID,
			},
		},
		Type: "User",
		Fields: map[string]*sqlgraph.FieldSpec{
			user.FieldUpdatedAt:          {Type: field.TypeTime, Column: user.FieldUpdatedAt},
			user.FieldCreatedAt:          {Type: field.TypeTime, Column: user.FieldCreatedAt},
			user.FieldDeletedAt:          {Type: field.TypeTime, Column: user.FieldDeletedAt},
			user.FieldDeletedBy:          {Type: field.TypeString, Column: user.FieldDeletedBy},
			user.FieldDisplayName:        {Type: field.TypeString, Column: user.FieldDisplayName},
			user.FieldAlias:              {Type: field.TypeString, Column: user.FieldAlias},
			user.FieldProfileImage:       {Type: field.TypeString, Column: user.FieldProfileImage},
			user.FieldExternalID:         {Type: field.TypeString, Column: user.FieldExternalID},
			user.FieldAuthProvider:       {Type: field.TypeEnum, Column: user.FieldAuthProvider},
			user.FieldRole:               {Type: field.TypeEnum, Column: user.FieldRole},
			user.FieldLastSeenAt:         {Type: field.TypeTime, Column: user.FieldLastSeenAt},
			user.FieldLastPostSeenCursor: {Type: field.TypeString, Column: user.FieldLastPostSeenCursor},
			user.FieldAwards:             {Type: field.TypeJSON, Column: user.FieldAwards},
		},
	}
	graph.MustAddE(
		"owner",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   apikey.OwnerTable,
			Columns: []string{apikey.OwnerColumn},
			Bidi:    false,
		},
		"ApiKey",
		"User",
	)
	graph.MustAddE(
		"owner",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   comment.OwnerTable,
			Columns: []string{comment.OwnerColumn},
			Bidi:    false,
		},
		"Comment",
		"User",
	)
	graph.MustAddE(
		"post",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   comment.PostTable,
			Columns: []string{comment.PostColumn},
			Bidi:    false,
		},
		"Comment",
		"Post",
	)
	graph.MustAddE(
		"owner",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   post.OwnerTable,
			Columns: []string{post.OwnerColumn},
			Bidi:    false,
		},
		"Post",
		"User",
	)
	graph.MustAddE(
		"comments",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   post.CommentsTable,
			Columns: []string{post.CommentsColumn},
			Bidi:    false,
		},
		"Post",
		"Comment",
	)
	graph.MustAddE(
		"saved_by",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   post.SavedByTable,
			Columns: post.SavedByPrimaryKey,
			Bidi:    false,
		},
		"Post",
		"User",
	)
	graph.MustAddE(
		"liked_by",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   post.LikedByTable,
			Columns: post.LikedByPrimaryKey,
			Bidi:    false,
		},
		"Post",
		"User",
	)
	graph.MustAddE(
		"categories",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   post.CategoriesTable,
			Columns: []string{post.CategoriesColumn},
			Bidi:    false,
		},
		"Post",
		"PostCategory",
	)
	graph.MustAddE(
		"post",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   postcategory.PostTable,
			Columns: []string{postcategory.PostColumn},
			Bidi:    false,
		},
		"PostCategory",
		"Post",
	)
	graph.MustAddE(
		"saved_posts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.SavedPostsTable,
			Columns: user.SavedPostsPrimaryKey,
			Bidi:    false,
		},
		"User",
		"Post",
	)
	graph.MustAddE(
		"liked_posts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.LikedPostsTable,
			Columns: user.LikedPostsPrimaryKey,
			Bidi:    false,
		},
		"User",
		"Post",
	)
	graph.MustAddE(
		"published_posts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.PublishedPostsTable,
			Columns: []string{user.PublishedPostsColumn},
			Bidi:    false,
		},
		"User",
		"Post",
	)
	graph.MustAddE(
		"comments",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CommentsTable,
			Columns: []string{user.CommentsColumn},
			Bidi:    false,
		},
		"User",
		"Comment",
	)
	graph.MustAddE(
		"api_key",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.APIKeyTable,
			Columns: []string{user.APIKeyColumn},
			Bidi:    false,
		},
		"User",
		"ApiKey",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (akq *ApiKeyQuery) addPredicate(pred func(s *sql.Selector)) {
	akq.predicates = append(akq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ApiKeyQuery builder.
func (akq *ApiKeyQuery) Filter() *ApiKeyFilter {
	return &ApiKeyFilter{config: akq.config, predicateAdder: akq}
}

// addPredicate implements the predicateAdder interface.
func (m *ApiKeyMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ApiKeyMutation builder.
func (m *ApiKeyMutation) Filter() *ApiKeyFilter {
	return &ApiKeyFilter{config: m.config, predicateAdder: m}
}

// ApiKeyFilter provides a generic filtering capability at runtime for ApiKeyQuery.
type ApiKeyFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ApiKeyFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql [16]byte predicate on the id field.
func (f *ApiKeyFilter) WhereID(p entql.ValueP) {
	f.Where(p.Field(apikey.FieldID))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *ApiKeyFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(apikey.FieldUpdatedAt))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *ApiKeyFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(apikey.FieldCreatedAt))
}

// WhereOwnerID applies the entql [16]byte predicate on the owner_id field.
func (f *ApiKeyFilter) WhereOwnerID(p entql.ValueP) {
	f.Where(p.Field(apikey.FieldOwnerID))
}

// WhereAPIKey applies the entql string predicate on the api_key field.
func (f *ApiKeyFilter) WhereAPIKey(p entql.StringP) {
	f.Where(p.Field(apikey.FieldAPIKey))
}

// WhereExpiresOn applies the entql time.Time predicate on the expires_on field.
func (f *ApiKeyFilter) WhereExpiresOn(p entql.TimeP) {
	f.Where(p.Field(apikey.FieldExpiresOn))
}

// WhereHasOwner applies a predicate to check if query has an edge owner.
func (f *ApiKeyFilter) WhereHasOwner() {
	f.Where(entql.HasEdge("owner"))
}

// WhereHasOwnerWith applies a predicate to check if query has an edge owner with a given conditions (other predicates).
func (f *ApiKeyFilter) WhereHasOwnerWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("owner", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (cq *CommentQuery) addPredicate(pred func(s *sql.Selector)) {
	cq.predicates = append(cq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the CommentQuery builder.
func (cq *CommentQuery) Filter() *CommentFilter {
	return &CommentFilter{config: cq.config, predicateAdder: cq}
}

// addPredicate implements the predicateAdder interface.
func (m *CommentMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the CommentMutation builder.
func (m *CommentMutation) Filter() *CommentFilter {
	return &CommentFilter{config: m.config, predicateAdder: m}
}

// CommentFilter provides a generic filtering capability at runtime for CommentQuery.
type CommentFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *CommentFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql [16]byte predicate on the id field.
func (f *CommentFilter) WhereID(p entql.ValueP) {
	f.Where(p.Field(comment.FieldID))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *CommentFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(comment.FieldUpdatedAt))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *CommentFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(comment.FieldCreatedAt))
}

// WhereDeletedAt applies the entql time.Time predicate on the deleted_at field.
func (f *CommentFilter) WhereDeletedAt(p entql.TimeP) {
	f.Where(p.Field(comment.FieldDeletedAt))
}

// WhereDeletedBy applies the entql string predicate on the deleted_by field.
func (f *CommentFilter) WhereDeletedBy(p entql.StringP) {
	f.Where(p.Field(comment.FieldDeletedBy))
}

// WhereOwnerID applies the entql [16]byte predicate on the owner_id field.
func (f *CommentFilter) WhereOwnerID(p entql.ValueP) {
	f.Where(p.Field(comment.FieldOwnerID))
}

// WhereContent applies the entql string predicate on the content field.
func (f *CommentFilter) WhereContent(p entql.StringP) {
	f.Where(p.Field(comment.FieldContent))
}

// WhereHasOwner applies a predicate to check if query has an edge owner.
func (f *CommentFilter) WhereHasOwner() {
	f.Where(entql.HasEdge("owner"))
}

// WhereHasOwnerWith applies a predicate to check if query has an edge owner with a given conditions (other predicates).
func (f *CommentFilter) WhereHasOwnerWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("owner", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasPost applies a predicate to check if query has an edge post.
func (f *CommentFilter) WhereHasPost() {
	f.Where(entql.HasEdge("post"))
}

// WhereHasPostWith applies a predicate to check if query has an edge post with a given conditions (other predicates).
func (f *CommentFilter) WhereHasPostWith(preds ...predicate.Post) {
	f.Where(entql.HasEdgeWith("post", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (pq *PostQuery) addPredicate(pred func(s *sql.Selector)) {
	pq.predicates = append(pq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the PostQuery builder.
func (pq *PostQuery) Filter() *PostFilter {
	return &PostFilter{config: pq.config, predicateAdder: pq}
}

// addPredicate implements the predicateAdder interface.
func (m *PostMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the PostMutation builder.
func (m *PostMutation) Filter() *PostFilter {
	return &PostFilter{config: m.config, predicateAdder: m}
}

// PostFilter provides a generic filtering capability at runtime for PostQuery.
type PostFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *PostFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql [16]byte predicate on the id field.
func (f *PostFilter) WhereID(p entql.ValueP) {
	f.Where(p.Field(post.FieldID))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *PostFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(post.FieldUpdatedAt))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *PostFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(post.FieldCreatedAt))
}

// WhereDeletedAt applies the entql time.Time predicate on the deleted_at field.
func (f *PostFilter) WhereDeletedAt(p entql.TimeP) {
	f.Where(p.Field(post.FieldDeletedAt))
}

// WhereDeletedBy applies the entql string predicate on the deleted_by field.
func (f *PostFilter) WhereDeletedBy(p entql.StringP) {
	f.Where(p.Field(post.FieldDeletedBy))
}

// WhereOwnerID applies the entql [16]byte predicate on the owner_id field.
func (f *PostFilter) WhereOwnerID(p entql.ValueP) {
	f.Where(p.Field(post.FieldOwnerID))
}

// WherePinned applies the entql bool predicate on the pinned field.
func (f *PostFilter) WherePinned(p entql.BoolP) {
	f.Where(p.Field(post.FieldPinned))
}

// WhereTitle applies the entql string predicate on the title field.
func (f *PostFilter) WhereTitle(p entql.StringP) {
	f.Where(p.Field(post.FieldTitle))
}

// WhereContent applies the entql string predicate on the content field.
func (f *PostFilter) WhereContent(p entql.StringP) {
	f.Where(p.Field(post.FieldContent))
}

// WhereLink applies the entql string predicate on the link field.
func (f *PostFilter) WhereLink(p entql.StringP) {
	f.Where(p.Field(post.FieldLink))
}

// WhereModerationComment applies the entql string predicate on the moderation_comment field.
func (f *PostFilter) WhereModerationComment(p entql.StringP) {
	f.Where(p.Field(post.FieldModerationComment))
}

// WhereIsModerated applies the entql bool predicate on the is_moderated field.
func (f *PostFilter) WhereIsModerated(p entql.BoolP) {
	f.Where(p.Field(post.FieldIsModerated))
}

// WhereEntityVector applies the entql string predicate on the entity_vector field.
func (f *PostFilter) WhereEntityVector(p entql.StringP) {
	f.Where(p.Field(post.FieldEntityVector))
}

// WhereHasOwner applies a predicate to check if query has an edge owner.
func (f *PostFilter) WhereHasOwner() {
	f.Where(entql.HasEdge("owner"))
}

// WhereHasOwnerWith applies a predicate to check if query has an edge owner with a given conditions (other predicates).
func (f *PostFilter) WhereHasOwnerWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("owner", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasComments applies a predicate to check if query has an edge comments.
func (f *PostFilter) WhereHasComments() {
	f.Where(entql.HasEdge("comments"))
}

// WhereHasCommentsWith applies a predicate to check if query has an edge comments with a given conditions (other predicates).
func (f *PostFilter) WhereHasCommentsWith(preds ...predicate.Comment) {
	f.Where(entql.HasEdgeWith("comments", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasSavedBy applies a predicate to check if query has an edge saved_by.
func (f *PostFilter) WhereHasSavedBy() {
	f.Where(entql.HasEdge("saved_by"))
}

// WhereHasSavedByWith applies a predicate to check if query has an edge saved_by with a given conditions (other predicates).
func (f *PostFilter) WhereHasSavedByWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("saved_by", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasLikedBy applies a predicate to check if query has an edge liked_by.
func (f *PostFilter) WhereHasLikedBy() {
	f.Where(entql.HasEdge("liked_by"))
}

// WhereHasLikedByWith applies a predicate to check if query has an edge liked_by with a given conditions (other predicates).
func (f *PostFilter) WhereHasLikedByWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("liked_by", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasCategories applies a predicate to check if query has an edge categories.
func (f *PostFilter) WhereHasCategories() {
	f.Where(entql.HasEdge("categories"))
}

// WhereHasCategoriesWith applies a predicate to check if query has an edge categories with a given conditions (other predicates).
func (f *PostFilter) WhereHasCategoriesWith(preds ...predicate.PostCategory) {
	f.Where(entql.HasEdgeWith("categories", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (pcq *PostCategoryQuery) addPredicate(pred func(s *sql.Selector)) {
	pcq.predicates = append(pcq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the PostCategoryQuery builder.
func (pcq *PostCategoryQuery) Filter() *PostCategoryFilter {
	return &PostCategoryFilter{config: pcq.config, predicateAdder: pcq}
}

// addPredicate implements the predicateAdder interface.
func (m *PostCategoryMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the PostCategoryMutation builder.
func (m *PostCategoryMutation) Filter() *PostCategoryFilter {
	return &PostCategoryFilter{config: m.config, predicateAdder: m}
}

// PostCategoryFilter provides a generic filtering capability at runtime for PostCategoryQuery.
type PostCategoryFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *PostCategoryFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[3].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql [16]byte predicate on the id field.
func (f *PostCategoryFilter) WhereID(p entql.ValueP) {
	f.Where(p.Field(postcategory.FieldID))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *PostCategoryFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(postcategory.FieldUpdatedAt))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *PostCategoryFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(postcategory.FieldCreatedAt))
}

// WhereCategory applies the entql string predicate on the category field.
func (f *PostCategoryFilter) WhereCategory(p entql.StringP) {
	f.Where(p.Field(postcategory.FieldCategory))
}

// WhereHasPost applies a predicate to check if query has an edge post.
func (f *PostCategoryFilter) WhereHasPost() {
	f.Where(entql.HasEdge("post"))
}

// WhereHasPostWith applies a predicate to check if query has an edge post with a given conditions (other predicates).
func (f *PostCategoryFilter) WhereHasPostWith(preds ...predicate.Post) {
	f.Where(entql.HasEdgeWith("post", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uq *UserQuery) addPredicate(pred func(s *sql.Selector)) {
	uq.predicates = append(uq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserQuery builder.
func (uq *UserQuery) Filter() *UserFilter {
	return &UserFilter{config: uq.config, predicateAdder: uq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserMutation builder.
func (m *UserMutation) Filter() *UserFilter {
	return &UserFilter{config: m.config, predicateAdder: m}
}

// UserFilter provides a generic filtering capability at runtime for UserQuery.
type UserFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[4].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql [16]byte predicate on the id field.
func (f *UserFilter) WhereID(p entql.ValueP) {
	f.Where(p.Field(user.FieldID))
}

// WhereUpdatedAt applies the entql time.Time predicate on the updated_at field.
func (f *UserFilter) WhereUpdatedAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldUpdatedAt))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *UserFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldCreatedAt))
}

// WhereDeletedAt applies the entql time.Time predicate on the deleted_at field.
func (f *UserFilter) WhereDeletedAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldDeletedAt))
}

// WhereDeletedBy applies the entql string predicate on the deleted_by field.
func (f *UserFilter) WhereDeletedBy(p entql.StringP) {
	f.Where(p.Field(user.FieldDeletedBy))
}

// WhereDisplayName applies the entql string predicate on the display_name field.
func (f *UserFilter) WhereDisplayName(p entql.StringP) {
	f.Where(p.Field(user.FieldDisplayName))
}

// WhereAlias applies the entql string predicate on the alias field.
func (f *UserFilter) WhereAlias(p entql.StringP) {
	f.Where(p.Field(user.FieldAlias))
}

// WhereProfileImage applies the entql string predicate on the profile_image field.
func (f *UserFilter) WhereProfileImage(p entql.StringP) {
	f.Where(p.Field(user.FieldProfileImage))
}

// WhereExternalID applies the entql string predicate on the external_id field.
func (f *UserFilter) WhereExternalID(p entql.StringP) {
	f.Where(p.Field(user.FieldExternalID))
}

// WhereAuthProvider applies the entql string predicate on the auth_provider field.
func (f *UserFilter) WhereAuthProvider(p entql.StringP) {
	f.Where(p.Field(user.FieldAuthProvider))
}

// WhereRole applies the entql string predicate on the role field.
func (f *UserFilter) WhereRole(p entql.StringP) {
	f.Where(p.Field(user.FieldRole))
}

// WhereLastSeenAt applies the entql time.Time predicate on the last_seen_at field.
func (f *UserFilter) WhereLastSeenAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldLastSeenAt))
}

// WhereLastPostSeenCursor applies the entql string predicate on the last_post_seen_cursor field.
func (f *UserFilter) WhereLastPostSeenCursor(p entql.StringP) {
	f.Where(p.Field(user.FieldLastPostSeenCursor))
}

// WhereAwards applies the entql json.RawMessage predicate on the awards field.
func (f *UserFilter) WhereAwards(p entql.BytesP) {
	f.Where(p.Field(user.FieldAwards))
}

// WhereHasSavedPosts applies a predicate to check if query has an edge saved_posts.
func (f *UserFilter) WhereHasSavedPosts() {
	f.Where(entql.HasEdge("saved_posts"))
}

// WhereHasSavedPostsWith applies a predicate to check if query has an edge saved_posts with a given conditions (other predicates).
func (f *UserFilter) WhereHasSavedPostsWith(preds ...predicate.Post) {
	f.Where(entql.HasEdgeWith("saved_posts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasLikedPosts applies a predicate to check if query has an edge liked_posts.
func (f *UserFilter) WhereHasLikedPosts() {
	f.Where(entql.HasEdge("liked_posts"))
}

// WhereHasLikedPostsWith applies a predicate to check if query has an edge liked_posts with a given conditions (other predicates).
func (f *UserFilter) WhereHasLikedPostsWith(preds ...predicate.Post) {
	f.Where(entql.HasEdgeWith("liked_posts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasPublishedPosts applies a predicate to check if query has an edge published_posts.
func (f *UserFilter) WhereHasPublishedPosts() {
	f.Where(entql.HasEdge("published_posts"))
}

// WhereHasPublishedPostsWith applies a predicate to check if query has an edge published_posts with a given conditions (other predicates).
func (f *UserFilter) WhereHasPublishedPostsWith(preds ...predicate.Post) {
	f.Where(entql.HasEdgeWith("published_posts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasComments applies a predicate to check if query has an edge comments.
func (f *UserFilter) WhereHasComments() {
	f.Where(entql.HasEdge("comments"))
}

// WhereHasCommentsWith applies a predicate to check if query has an edge comments with a given conditions (other predicates).
func (f *UserFilter) WhereHasCommentsWith(preds ...predicate.Comment) {
	f.Where(entql.HasEdgeWith("comments", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasAPIKey applies a predicate to check if query has an edge api_key.
func (f *UserFilter) WhereHasAPIKey() {
	f.Where(entql.HasEdge("api_key"))
}

// WhereHasAPIKeyWith applies a predicate to check if query has an edge api_key with a given conditions (other predicates).
func (f *UserFilter) WhereHasAPIKeyWith(preds ...predicate.ApiKey) {
	f.Where(entql.HasEdgeWith("api_key", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}
